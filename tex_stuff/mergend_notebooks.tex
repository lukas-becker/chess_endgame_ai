\documentclass[a4paper,12pt]{article}
	\usepackage{helvet}
    \renewcommand{\familydefault}{\sfdefault}
	\usepackage{setspace}
	\onehalfspacing
    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)
    \usepackage{tabto}
    \usepackage{iftex}
    \ifPDFTeX
    	\usepackage[T1]{fontenc}
    	\usepackage{mathpazo}
    \else
    	\usepackage{fontspec}
    \fi
	\usepackage[utf8]{inputenc}
    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range
    \makeatletter % fix for old versions of grffile with XeLaTeX
    \@ifpackagelater{grffile}{2019/11/01}
    {
      % Do nothing on new versions
    }
    {
      \def\Gread@@xetex#1{%
        \IfFileExists{"\Gin@base".bb}%
        {\Gread@eps{\Gin@base.bb}}%
        {\Gread@@xetex@aux#1}%
      }
    }
    \makeatother
    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % common color for the border for error outputs.
    \definecolor{outerrorbackground}{HTML}{FFDFDF}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \title{Entwicklung einer KI fÃ¼r das Schach-Endspiel \\ Studienarbeit} 
    
    
    
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\@namedef{PY@tok@w}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\@namedef{PY@tok@c}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cp}{\def\PY@tc##1{\textcolor[rgb]{0.61,0.40,0.00}{##1}}}
\@namedef{PY@tok@k}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kt}{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\@namedef{PY@tok@o}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ow}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@nb}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nf}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@ne}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.80,0.25,0.22}{##1}}}
\@namedef{PY@tok@nv}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@no}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\@namedef{PY@tok@nl}{\def\PY@tc##1{\textcolor[rgb]{0.46,0.46,0.00}{##1}}}
\@namedef{PY@tok@ni}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.44,0.44,0.44}{##1}}}
\@namedef{PY@tok@na}{\def\PY@tc##1{\textcolor[rgb]{0.41,0.47,0.13}{##1}}}
\@namedef{PY@tok@nt}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nd}{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@s}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sd}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@si}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.64,0.35,0.47}{##1}}}
\@namedef{PY@tok@se}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.36,0.12}{##1}}}
\@namedef{PY@tok@sr}{\def\PY@tc##1{\textcolor[rgb]{0.64,0.35,0.47}{##1}}}
\@namedef{PY@tok@ss}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sx}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@m}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@gh}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@gu}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\@namedef{PY@tok@gd}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\@namedef{PY@tok@gi}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.52,0.00}{##1}}}
\@namedef{PY@tok@gr}{\def\PY@tc##1{\textcolor[rgb]{0.89,0.00,0.00}{##1}}}
\@namedef{PY@tok@ge}{\let\PY@it=\textit}
\@namedef{PY@tok@gs}{\let\PY@bf=\textbf}
\@namedef{PY@tok@gp}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@go}{\def\PY@tc##1{\textcolor[rgb]{0.44,0.44,0.44}{##1}}}
\@namedef{PY@tok@gt}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\@namedef{PY@tok@err}{\def\PY@bc##1{{\setlength{\fboxsep}{\string -\fboxrule}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}}
\@namedef{PY@tok@kc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kr}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@bp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@fm}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@vc}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vg}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vi}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vm}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sa}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sb}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sc}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@dl}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s2}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sh}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s1}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@mb}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mf}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mh}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mi}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@il}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mo}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ch}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cm}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cpf}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@c1}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cs}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb. 
    \makeatletter
        \newbox\Wrappedcontinuationbox 
        \newbox\Wrappedvisiblespacebox 
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}} 
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}} 
        \newcommand*\Wrappedcontinuationindent {3ex } 
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox} 
        % Take advantage of the already applied Pygments mark-up to insert 
        % potential linebreaks for TeX processing. 
        %        {, <, #, %, $, ' and ": go to next line. 
        %        _, }, ^, &, >, - and ~: stay at end of broken line. 
        % Use of \textquotesingle for straight quote. 
        \newcommand*\Wrappedbreaksatspecials {% 
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}% 
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}% 
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}% 
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}% 
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}% 
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}% 
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}% 
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}% 
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}% 
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}% 
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}% 
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}% 
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}% 
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}% 
        } 
        % Some characters . , ; ? ! / are not pygmentized. 
        % This macro makes them "active" and they will insert potential linebreaks 
        \newcommand*\Wrappedbreaksatpunct {% 
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}% 
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}% 
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}% 
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}% 
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}% 
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}% 
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}% 
            \catcode`\.\active
            \catcode`\,\active 
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active 
            \lccode`\~`\~ 	
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%
        
        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active 	
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}
    
    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        {\ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}}
    }
    

    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    \usepackage[ngerman]{babel}


\begin{document}
	\pagenumbering{roman}
	\setcounter{page}{2}
	\section*{EhrenwÃ¶rtliche ErklÃ¤rung}
	Wir versichern hiermit, dass wir die Studienarbeit mit dem Thema:
	\begin{flushleft}
		\textit{''Entwicklung einer KI fÃ¼r das Schach-Endspiel"}
	\end{flushleft}
	selbststÃ¤ndig verfasst und keine anderen als die gegebenen Quellen und Hilfsmittel benutzt haben. \tab
	\linebreak
	\linebreak
	\linebreak
	\underline{\qquad \qquad \qquad \qquad \qquad \qquad } 
	\qquad \qquad \qquad \qquad 
	\underline{\qquad \qquad \qquad \qquad \qquad \qquad } \tab
	\linebreak
	\textit{Ort, Datum} 
	\qquad \qquad \qquad \qquad \qquad \qquad \qquad \quad 
	\textit{Unterschriften}
    \pagebreak

    \listoffigures
	\section*{Anmerkung}
	Aus GrÃ¼nden der besseren Lesbarkeit wird in dieser Arbeit fÃ¼r alle personenbezogenen Begriffe (z.B. Nutzer etc.) nur die mÃ¤nnliche Sprachform verwendet. SÃ¤mtliche Personenbezeichnungen gelten gleichermaÃen fÃ¼r jedes Geschlecht.
    \pagebreak
    \tableofcontents
    \pagebreak
    \pagenumbering{arabic}
    \hypertarget{einleitung}{%
\section{Einleitung}\label{einleitung}}

    Bevor in die Umsetzung der Aufgabe eingestiegen wird, werden einige
Grundlagen des Schachspiels fÃ¼r den ungeschulten Spieler erklÃ¤rt.
Dadurch kÃ¶nnen die Schritte zur Berechnung eines optimalen Endspiels
besser nachvollzogen werden.

    \hypertarget{schach}{%
\section{Schach}\label{schach}}

    Bei Schach handelt es sich um ein Brettspiel, das insgesamt von zwei
Spielern gespielt werden kann. Im folgenden Abschnitt soll eine
EinfÃ¼hrung in den Spielablauf gegeben werden. Diese wird benÃ¶tigt, um
die im Verlauf dieses Dokuments vorgestellten Konzepte zu verstehen.

    \hypertarget{spielbrett-und-spielfiguren}{%
\subsection{Spielbrett und
Spielfiguren}\label{spielbrett-und-spielfiguren}}

Ein Schachbrett besteht aus insgesamt 64 Feldern, die in einer 8x8
Matrix angeordnet sind. Dabei werden die Spalten mit den Buchstaben a-h
und die Zeilen mit den Zahlen 1-8 beschriftet. Das typische Schachmuster
entsteht durch einen regelmÃ¤Ãigen Wechsel zwischen weiÃen und schwarzen
bzw. dunklen und hellen Feldern. Dementsprechend sind insgesamt 32 weiÃe
und 32 schwarze Felder auf dem Schachbrett zu finden. Alle Felder kÃ¶nnen
mithilfe der zuvor genannten Beschriftung eindeutig identifiziert
werden. Wenn in diesem Dokument Felder durch ein KÃ¼rzel wie
beispielsweise ``c5'' spezifiziert werden, ist das Feld gemeint, das in
der Spalte ``\emph{Buchstabe}'' und der Zeile ``\emph{Zahl}'' zu finden
ist. Das vorherige Beispiel befindet sich also in der dritten (c) Spalte
und der fÃ¼nften (5) Zeile.

Im Folgenden werden die Spalten des Schachbretts als Linien und die
Zeilen als Reihen bezeichnet.

Dieses Schachbrett wird maximal von 32 Figuren besetzt (16 weiÃe und 16
schwarze Figuren). Eine Seite besteht aus insgesamt sechs
unterschiedlichen Figuren. Bei diesen Figuren handelt es sich um:

\begin{itemize}
\tightlist
\item
  Bauern (8)
\item
  Springer (2)
\item
  LÃ¤ufer (2)
\item
  TÃ¼rme (2)
\item
  Dame (1)
\item
  KÃ¶nig (1)
\end{itemize}

Die Zahl in den Klammern steht hierbei fÃ¼r die Anzahl an Figuren pro
Spieler. Die Aufstellung zu Beginn des Spiels kann aus der folgenden
Abbildung entnommen werden:

\begin{figure}
\centering
\includegraphics{../Abbildungen/Grundaufstellung.png}
\caption{Grundaufstellung}
\end{figure}

    \hypertarget{bewegungsmuxf6glichkeiten-der-figuren}{%
\subsubsection{BewegungsmÃ¶glichkeiten der
Figuren}\label{bewegungsmuxf6glichkeiten-der-figuren}}

Jede der bereits genannten Figuren hat einen Wert und ein
Bewegungsmuster. Figuren kÃ¶nnen im Rahmen dieses Bewegungsmuster bewegt
werden, werden aber durch andere Figuren blockiert. Eine Figur kann nur
in AusnahmefÃ¤llen Ã¼bersprungen werden und blockiert grundsÃ¤tzlich die
Bewegungen aller anderen Figuren. Figuren des Gegners (der anderen
Farbe) kÃ¶nnen geschlagen werden, indem eine eigene Figur auf dasselbe
Feld gestellt wird. Eine geschlagene Figur wird vom Spielfeld entfernt.
Zwei Figuren derselben Farbe kÃ¶nnen nicht auf demselben Feld platziert
werden. Diese lauten wie folgt (Jonathan Carlstedt, Die kleine
Schachschule (2015): S.10ff., S.40): 
\begin{itemize}
	\item 
		\textbf{KÃ¶nig} (unendlich): Der
		KÃ¶nig gehÃ¶rt zu den unbeweglichsten Figuren auf dem Spielfeld. Er kann
		pro Zug nur ein Feld entlang einer Reihe, Linie oder Diagonalen bewegt
		werden. Dadurch besitzt er jedoch die MÃ¶glichkeit, in jede Richtung eine
		gegnerische Figur zu schlagen. Als weitere EinschrÃ¤nkung muss beim
		Ziehen mit dem KÃ¶nig beachtet werden, dass das angestrebte Feld nicht
		durch eine gegnerische Figur abgedeckt wird. Ein Feld gilt als
		abgedeckt, wenn eine gegnerische Figur es in einem Zug betreten und die
		darauf stehende Figur schlagen kann. Ist dies der Fall, darf der KÃ¶nig
		nicht auf dieses Feld gesetzt werden.
		\begin{figure}
			\centering
			\includegraphics{../Abbildungen/KÃ¶nig.png} 
			\caption{Bewegungsmuster KÃ¶nig}
		\end{figure}
	\item 
		\textbf{Turm} (5): Der Turm
		besitzt die MÃ¶glichkeit, in einer Reihe oder Linie beliebig viele Felder
		zu Ã¼berqueren (maximal bis zum Ende des Spielfeldes).
		
		\begin{figure}
			\centering
			\includegraphics{../Abbildungen/Turm.png} 
			\caption{Bewegungsmuster Turm}
		\end{figure}
	
	\item 
		\textbf{LÃ¤ufer} (3): Der
		LÃ¤ufer kann wie ein Turm in geraden Linien bewegt werden. Er
		unterscheidet sich dadurch, dass er nur diagonal bewegt werden kann. Ein
		LÃ¤ufer auf dem Feld ``a1'' kann folglich nur nach ``b2'' oder entlang
		der Diagonale bewegt werden. 
		
		\begin{figure}
			\centering
			\includegraphics{../Abbildungen/LÃ¤ufer.png} 
			\caption{Bewegungsmuster LÃ¤ufer}
		\end{figure}
	
	\item 
		\textbf{Dame} (9): Die Dame zÃ¤hlt zu den beweglichsten Figuren auf dem
		Spielfeld. Sie kombiniert die Bewegungsmuster des LÃ¤ufers und des Turms.
		Das bedeutet, dass sie horizontal (entlang der Reihen), vertikal
		(entlang der Linien) und diagonal bewegt werden kann.
		
		\begin{figure}
			\centering
			\includegraphics{../Abbildungen/Dame.png} 
			\caption{Bewegungsmuster Dame}
		\end{figure}
	
	\item
		\textbf{Bauer} (1): Der
		Bauer ist die Figur mit der geringsten Beweglichkeit. Dieser kann nur
		entlang der Linie nach vorne bewegt werden. Die erste Bewegung jedes
		Bauern kann ein oder zwei Felder weit sein, folgende Bewegungen sind
		immer genau ein Feld weit. Eine Besonderheit des Bauerns, liegt in der
		Richtung, in die ein Bauer gegnerische Figuren schlagen darf. Dieser
		darf nur diagonal nach vorne schlagen. Weiter wird der Bauer in eine
		beliebige Spielfigur (auÃer einem Bauern und einem zweiten KÃ¶nig)
		gewandelt, sobald er die Grundlinie des Gegners erreicht hat.
		
		\begin{figure}
			\centering
			\includegraphics{../Abbildungen/Bauer.png} 
			\caption{Bewegungsmuster Bauer}
		\end{figure}
	
	\item
		\textbf{Springer} (3): Der
		Springer besitzt im Gegensatz zu allen bereits beschriebenen Figuren
		keine lineare Bewegungsrichtung. Er kann um zwei Felder nach vorne und
		ein Feld zur Seite versetzt werden. Dieses Verfahren gilt in jede
		Richtung, sodass der Springer im Optimalfall acht Felder erreichen kann.
		Der Name des Springers kommt dadurch zustande, dass er die einzige Figur
		ist, die andere Figuren Ã¼berspringen kann. Nur das ``Zielfeld'' kann
		durch eine eigene Figur blockiert werden.
		
		\begin{figure}
			\centering
			\includegraphics{../Abbildungen/Springer.png} 
			\caption{Bewegungsmuster Soringer}
		\end{figure}
\end{itemize}


    \hypertarget{spielablauf}{%
\subsection{Spielablauf}\label{spielablauf}}

    In einem Spiel ziehen die Spieler immer abwechselnd eine Figur ihrer
Farbe. Den ersten Zug hat dabei immer weiÃ.

Beide Spieler verfolgen wÃ¤hrend der ganzen Partie das Ziel, den
gegnerischen Spieler Schach-Matt zu setzen. Ein Spieler ist Schach-Matt,
wenn folgende Bedingungen erfÃ¼llt sind: 1. Der KÃ¶nig wird durch eine
gegnerische Figur bedroht. 2. Der KÃ¶nig kann dieser Bedrohung nicht
ausweichen.

Eine solche Bedrohung liegt vor, wenn der gegnerische Spieler im
nÃ¤chsten Zug den KÃ¶nig schlagen kann. Dies kann auf drei
unterschiedliche Weisen pariert werden: 1. Der KÃ¶nig bewegt sich aus dem
``Schach''. 2. Der Spieler schlÃ¤gt die Schach-gebende Figur. 3. Eine
Figur stellt sich zwischen die Schach-gebende Figur und den KÃ¶nig.

Ein anderer Spielausgang neben dem Schach-Matt liegt in dem Patt. Ein
Patt ist dann gegeben, wenn der Spieler, der am Zug ist, keine Figur
mehr ziehen kann und der KÃ¶nig des Ziehenden nicht im Schach steht.

    Da diese Studienarbeit nicht vorsieht, das komplette Schachspiel zu
erklÃ¤ren, werden die restlichen Spielregeln nicht nÃ¤her erlÃ¤utert. Diese
werden aber in der
\href{https://python-chess.readthedocs.io/en/latest/}{python-chess}
Bibliothek, welche fÃ¼r die Abbildung des Schachspiels im Code verwendet
wird, umgesetzt und berÃ¼cksichtigt.

    Anhand der Nummerierung der Notebooks kÃ¶nnen nun die einzelnen Schritte
zur Erstellung und Validierung einer Schach-Endspiel-KI nachvollzogen
werden. Die einzelnen Notebooks begleiten chronologisch die Erstellung,
Validierung und Verwendung einer Endspiel-KI. Die hierfÃ¼r notwendigen
Notebooks sind:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  02\_calculation.ipynb
\item
  03\_play\_against\_ai.ipynb
\item
  04\_play\_from\_history.ipynb
\item
  05\_stockfish\_compare.ipynb
\item
  06\_validate\_sequences.ipynb
\end{enumerate}

Im Util-Ordner werden zusÃ¤tzlich allgemeine Importe und Funktionen
aufgelistet, die fÃ¼r die AusfÃ¼hrung der aufgelisteten Notebooks benÃ¶tigt
werden.

In der PDF-Version dieser Arbeit ist jedes der aufgelisteten Notebooks
ein Kapitel.

    \hypertarget{berechnung-der-endspieldatenbank}{%
\section{Berechnung der
Endspieldatenbank}\label{berechnung-der-endspieldatenbank}}

Wie in Notebook \texttt{01\_chess\_introduction} bereits erklÃ¤rt, ist
ein Schachspiel gewonnen, wenn die gegnerische Figur mattgesetzt wurde.

Bei einer geringen Anzahl an Figuren \(P\) im Spielzustand lassen sich
alle mÃ¶glichen Positionen berechnen. Aus diesen kann eine Strategie
entwickelt werden, den Gegner zu schlagen.

Im weiteren Verlauf werden folgende Definitionen verwendet: 
\begin{itemize}
	\item \(board.pieces\): Liste der Figuren, welche in einem Zustand vorhanden sind. 
	\item \(valid\_boards\): Alle ZustÃ¤nde des Schachspiels, die gegen keine Regeln verstoÃen. 
	\item \(won\_boards\): Alle ZustÃ¤nde des Schachspiels, in denen ein Spieler gewonnen hat. 
	\item \(previous\_states(b)\): Alle ZustÃ¤nde, aus denen durch AusfÃ¼hren eines einzelnen Zuges der Zustand \(b\) erreicht werden kann.
\end{itemize}


Seien alle mÃ¶glichen (validen) Kombinationen von Positionen der Figuren
\(P\) die Menge \(S\).\\
FÃ¼r \(S\) gilt:\\
\[
board \in S \implies \forall p \in P : p \in board.pieces \\
\land \\
board \in S \implies board \in valid\_Boards
\]

Aus der Menge \(S\) lassen sich ZustÃ¤nde auswÃ¤hlen, welche \(n\) ZÃ¼ge
vom Sieg entfernt sind. Diese ZustÃ¤nde lassen sich in \(S_n\)
zusammenfassen. Ist das Spiel gewonnen, verbleiben 0 ZÃ¼ge bis zum
Sieg.\\
FÃ¼r alle diese ZustÃ¤nde, in denen ein Spieler mattgesetzt ist, gilt:\\
\[
board \in S_0 \implies board \in won\_boards \land board \in S
\] Aus dieser Definition kÃ¶nnen induktiv die verbleibenden \(S_n\)
hergeleitet werden:\\
\[board \in S_{n+1} \iff board \in S \land \exists b \in S_n: board \in previous\_states(b)\]

FÃ¼r die Berechnungen in diesem Notebook gilt da fÃ¼r den schwarzen
Spieler immer nur der KÃ¶nig auf dem Feld steht weiter Folgendes:\\
\(board.turn\): Der Spieler, welcher am Zug ist.

\[
n \equiv 0 \mod 2 \implies \forall b \in S_n : b.turn = schwarz \\
\]
\[
\land 
\]
\[ 
n \equiv 1 \mod 2 \implies \forall b \in S_n : b.turn = weiss \\
\]

Dieses Notebook wird zur Berechnung der \(S_n\) Mengen verwendet. Diese
werden benÃ¶tigt, um letztendlich ein Schach-Endspiel lÃ¶sen zu kÃ¶nnen.

    \hypertarget{ein-hinweis-zu-spiegelungen}{%
\subsection{Ein Hinweis zu
Spiegelungen}\label{ein-hinweis-zu-spiegelungen}}

In diesem Notebook werden Spiegelungen der Situationen verwendet. Die
technische Umsetzung dieser Spiegelungen werden im Verlauf des Dokuments
erklÃ¤rt, an dieser Stelle soll lediglich eine EinfÃ¼hrung in die Theorie
hinter dem Spiegeln von Situationen erklÃ¤rt werden.

Durch die zuvor erklÃ¤rten Bewegungsmuster der Figuren sind Schachbretter
in vielen FÃ¤llen symmetrisch.

Eine Position mit dem Turm in ``a8'', der Dame in ``g6'' und dem
gegnerischen KÃ¶nig in ``h8'' ist genauso verloren wie dieselbe Position
nur mit dem Turm in ``a1'', der Dame in ``g3'' und dem KÃ¶nig in ``h1''.
Dies wÃ¤re eine Spiegelung entlang der horizontalen zwischen den Zeilen 4
und 5. Weiter sind auch Spiegelungen entlang der vertikalen (Zwischen
Reihe e und f), den Diagonalen und Rotationen (jeweils um 90Â°, 180Â° und
270Â°) mÃ¶glich.

Durch das simple Spiegeln der Spielsituationen kÃ¶nnen aus einer validen
Spielsituation bis zu sieben weitere ohne groÃen Rechenaufwand
erstellen. Aus diesem Grund werden in diesem Dokument bei jeder
Berechnung neuer Situationen diese gespiegelt und die Spiegelungen
ebenfalls Ã¼berprÃ¼ft und abgespeichert.

Da Bauern sich nur in eine Richtung bewegen kÃ¶nnen, werden nur
Spielsituationen gespiegelt, welche keine Bauern enthalten.

    \hypertarget{ein-hinweis-zur-effizienten-ergebnisverwaltung}{%
\subsection{Ein Hinweis zur effizienten
Ergebnisverwaltung}\label{ein-hinweis-zur-effizienten-ergebnisverwaltung}}

Im Verlauf der Berechnung muss mehrfach Ã¼berprÃ¼ft werden, ob eine
Situation bereits bekannt und einem \(S_n\) zugeordnet ist. Da der
Abgleich mit einer Liste in Python ineffizient ist, findet dieser
Abgleich mit Mengen statt. Mengen werden in Python als Hash-Tabellen
umgesetzt und haben damit eine ZeitkomplexitÃ¤t bei der ÃberprÃ¼fung, ob
sie ein bestimmtes Element enthalten von \(\mathcal{O}(1)\).
\texttt{board} Objekte der \texttt{chess} Library sind jedoch nicht
``Hashbar''. Im Sinne der in dieser Arbeit getÃ¤tigten Berechnungen
reichen die Informationen Ã¼ber die Stellung der Figuren und dem Spieler,
welcher am Zug ist, aus. Es wird daher fÃ¼r die Verwendung in Python
Mengen mit einer Tupel-ReprÃ¤sentation der Situationen wie folgt
gearbeitet: \[
Tupel := <board.turn, board.\_\_str\_\_()>
\] Die Funktion \texttt{board.\_\_str\_\_()} gibt einen String zurÃ¼ck,
welcher ein Schachbrett wie folgt darstellt:

\begin{verbatim}
'r n b q k b n r\np p p p p p p p\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\nP P P P P P P P\nR N B Q K B N R'
\end{verbatim}

Die Eigenschaft \texttt{board.turn} ist ein boolscher Wert. Sowohl
Tupel, als auch Strings und boolsche Werte sind in Python ``Hashable'',
weshalb diese Darstellung in Mengen verwendet werden kann.

Um die Effizienz weiter zu steigern, berechnet dieses Notebook nicht
alle Situationen \(S\) und entfernt daraus die Situationen fÃ¼r ein
\(S_n\) wie in der Aufgabenstellung beschrieben. Stattdessen werden alle
bekannten Situationen in \texttt{used\_boards} gespeichert. Dopplungen
werden also nicht vermieden indem Situationen aus einer groÃen Liste
entfernt werden, sondern eine Liste der entfernten Situationen gefÃ¼hrt
und neue Situationen mit dieser abgeglichen.

    \hypertarget{funktionen-zur-bestimmung-aller-guxfcltigen-positionen}{%
\subsection{Funktionen zur Bestimmung aller gÃ¼ltigen
Positionen}\label{funktionen-zur-bestimmung-aller-guxfcltigen-positionen}}

Wie bereits in \texttt{01\_chess\_introduction} beschrieben, besteht ein
Schachbrett aus insgesamt acht Spalten und Zeilen. Die Spalten werden
durch Buchstaben gekennzeichnet, die Zeilen durch Zahlen. Aus der
Kombination einer Spalte (z.B. a) und einer Zahl (z.B. 1) erhÃ¤lt man
eine eindeutige Kennzeichnung fÃ¼r ein Feld (z.B. a1).\\
Die folgende Funktion kombiniert die Buchstaben a bis h mit den Zahlen 1
bis 8 zu Feldnamen und gibt diese zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{get\PYZus{}all\PYZus{}squares}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n}{columns} \PY{o}{=} \PY{p}{\PYZob{}}
        \PY{l+m+mi}{1} \PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
        \PY{l+m+mi}{2} \PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
        \PY{l+m+mi}{3} \PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
        \PY{l+m+mi}{4} \PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{d}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
        \PY{l+m+mi}{5} \PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{e}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
        \PY{l+m+mi}{6} \PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{f}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
        \PY{l+m+mi}{7} \PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{g}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
        \PY{l+m+mi}{8} \PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{h}\PY{l+s+s1}{\PYZsq{}}
    \PY{p}{\PYZcb{}}
    
    \PY{n}{all\PYZus{}squares} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{k}{for} \PY{n}{row} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{9}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{col\PYZus{}num} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{9}\PY{p}{)}\PY{p}{:}
            \PY{n}{column} \PY{o}{=} \PY{n}{columns}\PY{p}{[}\PY{n}{col\PYZus{}num}\PY{p}{]}
            \PY{n}{all\PYZus{}squares}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{chess}\PY{o}{.}\PY{n}{parse\PYZus{}square}\PY{p}{(}\PY{n}{column} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{row}\PY{p}{)}\PY{p}{)}\PY{p}{)}
            
    \PY{k}{return} \PY{n}{all\PYZus{}squares}
\end{Verbatim}
\end{tcolorbox}

    Das Erstellen jeglicher Boards wird mit der Funktion
\texttt{place\_piece\_everywhere\_on\_every\_board} umgesetzt. Diese
erhÃ¤lt folgende Parameter:

\begin{itemize}
\tightlist
\item
  \texttt{piece}: Die zu platzierende Figur als Objekt der
  chess-Library.
\item
  \texttt{list\_of\_boards}: Eine Liste mit Board-Objekten, auf welchen
  die Figur platziert werden soll.
\end{itemize}

Die Funktion betrachtet jede Situation in der \texttt{list\_of\_boards}.
Das Ã¼bergebene \texttt{piece} wird auf jeden freien Platz dieser
Situation platziert. Jedes Mal, wenn eine Figur platziert wird, wird
eine Kopie des Board-Objektes erstellt, die \texttt{list\_of\_boards}
wird folglich nicht verÃ¤ndert.\\
Wenn der zweite KÃ¶nig platziert wird, wird die Situation zusÃ¤tzlich auf
ValiditÃ¤t Ã¼berprÃ¼ft. Wenn alle Figuren platziert wurden, werden nur
Boards, in denen Schwarz matt ist, zurÃ¼ckgegeben.

Um die Effizienz der Berechnung zu erhÃ¶hen, werden die Schachbretter
gespiegelt. Damit bei folgenden Berechnungen Situationen nicht einmal
durch Spiegelung und einmal durch Bewegung von Figuren erreicht werden,
werden die ungespiegelten Situationen in der Liste \texttt{uniques}
gespeichert.

Die Funktion gibt als Ergebnis eine Liste aller generierten ZustÃ¤nde als
\texttt{result\_list}, die Menge der bereits verwendeten Situationen
\texttt{used\_boards} und alle ungespiegelten Boards (vor Spiegelungen)
\texttt{uniques} zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{place\PYZus{}figure\PYZus{}everywhere\PYZus{}on\PYZus{}every\PYZus{}board}\PY{p}{(}\PY{n}{piece}\PY{p}{,} \PY{n}{list\PYZus{}of\PYZus{}boards}\PY{p}{,} \PY{n}{piece\PYZus{}count}\PY{p}{,} \PY{n}{user\PYZus{}wants\PYZus{}pawn}\PY{p}{)}\PY{p}{:}
    \PY{n}{result\PYZus{}list} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{uniques} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{all\PYZus{}squares} \PY{o}{=} \PY{n}{get\PYZus{}all\PYZus{}squares}\PY{p}{(}\PY{p}{)}
    \PY{n}{used\PYZus{}boards} \PY{o}{=} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}
    
    \PY{k}{for} \PY{n}{board} \PY{o+ow}{in} \PY{n}{list\PYZus{}of\PYZus{}boards}\PY{p}{:}
        \PY{n}{squares\PYZus{}used} \PY{o}{=} \PY{n+nb}{list}\PY{p}{(}\PY{n}{board}\PY{o}{.}\PY{n}{piece\PYZus{}map}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{keys}\PY{p}{(}\PY{p}{)}\PY{p}{)}
        \PY{k}{for} \PY{n}{square} \PY{o+ow}{in} \PY{n}{all\PYZus{}squares}\PY{p}{:}
            \PY{k}{if} \PY{n}{square} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{squares\PYZus{}used}\PY{p}{:}
                \PY{n}{tmp\PYZus{}board} \PY{o}{=} \PY{n}{board}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{p}{)}
                \PY{n}{tmp\PYZus{}board}\PY{o}{.}\PY{n}{set\PYZus{}piece\PYZus{}at}\PY{p}{(}\PY{n}{square}\PY{p}{,} \PY{n}{piece}\PY{p}{)}
                
                \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{squares\PYZus{}used}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{1} \PY{o+ow}{and} \PY{o+ow}{not} \PY{n}{tmp\PYZus{}board}\PY{o}{.}\PY{n}{is\PYZus{}valid}\PY{p}{(}\PY{p}{)}\PY{p}{:} 
                    \PY{c+c1}{\PYZsh{} Don\PYZsq{}t process invalid boards further }
                    \PY{c+c1}{\PYZsh{} than the second king}
                    \PY{k}{continue}
                    
                \PY{n}{outcome} \PY{o}{=} \PY{n}{tmp\PYZus{}board}\PY{o}{.}\PY{n}{outcome}\PY{p}{(}\PY{p}{)}
                \PY{k}{if} \PY{n}{outcome} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
                    \PY{n}{rep} \PY{o}{=} \PY{p}{(}\PY{n}{tmp\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{,} \PY{n}{tmp\PYZus{}board}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}
                    \PY{k}{if} \PY{n}{outcome}\PY{o}{.}\PY{n}{winner} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None} \PY{o+ow}{and} \PY{n}{tmp\PYZus{}board}\PY{o}{.}\PY{n}{is\PYZus{}valid}\PY{p}{(}\PY{p}{)} \PY{o+ow}{and} \PY{n}{rep} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{used\PYZus{}boards}\PY{p}{:}
                        \PY{n}{uniques}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{tmp\PYZus{}board}\PY{p}{)}
                        \PY{n}{result\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{tmp\PYZus{}board}\PY{p}{)}
                        \PY{n}{used\PYZus{}boards}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{p}{(}\PY{n}{tmp\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{,}\PY{n}{tmp\PYZus{}board}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}\PY{p}{)}
                        \PY{k}{if} \PY{o+ow}{not} \PY{n}{user\PYZus{}wants\PYZus{}pawn}\PY{p}{:}
                            \PY{k}{for} \PY{n}{swt} \PY{o+ow}{in} \PY{n}{Swap\PYZus{}Type}\PY{p}{:}
                                \PY{n}{mir\PYZus{}board} \PY{o}{=} \PY{n}{mirror}\PY{p}{(}\PY{n}{tmp\PYZus{}board}\PY{p}{,} \PY{n}{swt}\PY{p}{)}
                                \PY{k}{if} \PY{p}{(}\PY{n}{mir\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{,} \PY{n}{mir\PYZus{}board}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{used\PYZus{}boards}\PY{p}{:}
                                    \PY{n}{result\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{mir\PYZus{}board}\PY{p}{)}
                                    \PY{n}{used\PYZus{}boards}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{p}{(}\PY{n}{mir\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{,}\PY{n}{mir\PYZus{}board}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}\PY{p}{)}
                        \PY{k}{continue}
                        
                \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{squares\PYZus{}used}\PY{p}{)} \PY{o}{+} \PY{l+m+mi}{1} \PY{o}{\PYZlt{}} \PY{n}{piece\PYZus{}count}\PY{p}{:} \PY{c+c1}{\PYZsh{}Board is valid, but needs more pieces}
                    \PY{n}{result\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{tmp\PYZus{}board}\PY{p}{)}
    \PY{k}{return} \PY{n}{result\PYZus{}list}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{uniques}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{die-ursprungsmenge-s_0-erstellen}{%
\subsection{\texorpdfstring{Die Ursprungsmenge \(S_0\)
erstellen}{Die Ursprungsmenge S\_0 erstellen}}\label{die-ursprungsmenge-s_0-erstellen}}

Als Basis der Berechnung dient die Liste \(S_0\). Diese enthÃ¤lt alle
mÃ¶glichen Konstellationen der Spielfiguren auf dem Spielbrett, in denen
WeiÃ Schwarz besiegt hat. HierfÃ¼r werden die Figuren mit der Funktion
\texttt{place\_figure\_everywhere\_on\_every\_board} auf allen
Positionen platziert.

Die Funktion \texttt{setup\_boards} automatisiert dies und gibt die
Liste \(S_0\), eine Menge der bereits bekannten Situationen
\texttt{used\_boards} und die Menge der ungespiegelten Situationen
\texttt{uniques} zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{setup\PYZus{}boards}\PY{p}{(}\PY{n}{user\PYZus{}supplied\PYZus{}pieces}\PY{p}{,} \PY{n}{user\PYZus{}wants\PYZus{}pawn}\PY{p}{)}\PY{p}{:}
    \PY{n}{pieces\PYZus{}to\PYZus{}place} \PY{o}{=} \PY{n}{create\PYZus{}piece\PYZus{}list}\PY{p}{(}\PY{n}{user\PYZus{}supplied\PYZus{}pieces}\PY{p}{)}
    
    \PY{n}{empty\PYZus{}board} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Board}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{empty}\PY{p}{(}\PY{p}{)}
    \PY{n}{empty\PYZus{}board}\PY{o}{.}\PY{n}{turn} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{BLACK}
    \PY{n}{s\PYZus{}0} \PY{o}{=} \PY{p}{[}\PY{n}{empty\PYZus{}board}\PY{p}{]}
    
    \PY{n}{piece\PYZus{}count} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{pieces\PYZus{}to\PYZus{}place}\PY{p}{)}
    \PY{k}{for} \PY{n}{piece} \PY{o+ow}{in} \PY{n}{pieces\PYZus{}to\PYZus{}place}\PY{p}{:}
        \PY{n}{s\PYZus{}0}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{uniques} \PY{o}{=} \PY{n}{place\PYZus{}figure\PYZus{}everywhere\PYZus{}on\PYZus{}every\PYZus{}board}\PY{p}{(}\PY{n}{piece}\PY{p}{,} \PY{n}{s\PYZus{}0}\PY{p}{,} \PY{n}{piece\PYZus{}count}\PY{p}{,} \PY{n}{user\PYZus{}wants\PYZus{}pawn}\PY{p}{)}

    \PY{n+nb}{print}\PY{p}{(}\PY{n+nb}{str}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{s\PYZus{}0}\PY{p}{)}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ Boards in S\PYZus{}0}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{k}{return} \PY{n}{s\PYZus{}0}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{uniques}
\end{Verbatim}
\end{tcolorbox}

    Bevor die Boards fÃ¼r \(S_0\) erstellt werden kÃ¶nnen, mÃ¼ssen die vom
Nutzer getÃ¤tigten Eingaben zu den zu verwendeten Figuren mit den immer
vorhandenen Figuren kombiniert werden. Weiter wird ein eingegebener
Bauer durch eine KÃ¶nigin ersetzt. Ein Endspiel mit zwei KÃ¶nigen und
einem Bauer kann nicht gewonnen werden, weshalb keine Situationen fÃ¼r
\(S_0\) gefunden werden wÃ¼rden. Die KÃ¶nigin wird spÃ¤ter im Ablauf wieder
durch einen Bauern ersetzt. Die Theorie hinter diesem Tausch wird zu
einem spÃ¤terem Zeitpunkt erklÃ¤rt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} A queen will automatically be replaced by a pawn}
\PY{k}{def} \PY{n+nf}{create\PYZus{}piece\PYZus{}list}\PY{p}{(}\PY{n}{user\PYZus{}supplied\PYZus{}pieces}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{chess}\PY{o}{.}\PY{n}{Piece}\PY{o}{.}\PY{n}{from\PYZus{}symbol}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{P}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{o+ow}{in} \PY{n}{user\PYZus{}supplied\PYZus{}pieces}\PY{p}{:}
        \PY{n}{user\PYZus{}supplied\PYZus{}pieces}\PY{o}{.}\PY{n}{remove}\PY{p}{(}\PY{n}{chess}\PY{o}{.}\PY{n}{Piece}\PY{o}{.}\PY{n}{from\PYZus{}symbol}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{P}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{)}
        \PY{n}{user\PYZus{}supplied\PYZus{}pieces}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{chess}\PY{o}{.}\PY{n}{Piece}\PY{o}{.}\PY{n}{from\PYZus{}symbol}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Q}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{)}
        
    \PY{k}{return} \PY{p}{[}\PY{n}{chess}\PY{o}{.}\PY{n}{Piece}\PY{o}{.}\PY{n}{from\PYZus{}symbol}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{K}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{,} \PY{n}{chess}\PY{o}{.}\PY{n}{Piece}\PY{o}{.}\PY{n}{from\PYZus{}symbol}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{k}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{]} \PYZbs{}
           \PY{o}{+} \PY{n}{user\PYZus{}supplied\PYZus{}pieces}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{ruxfcckwuxe4rts-neue-situationen-bestimmen}{%
\subsection{RÃ¼ckwÃ¤rts neue Situationen
bestimmen}\label{ruxfcckwuxe4rts-neue-situationen-bestimmen}}

Der nÃ¤chste Schritt besteht darin, sÃ¤mtliche \(S_{n}\) Mengen zu
bestimmen. Hierzu wird eine bereits bestimmte \(S_n\) Menge genommen und
alle Situationen berechnet, die durch DurchfÃ¼hren eines Zugs zu einer
Situation aus \(S_n\) werden.

Besonders muss bei dieser Art der Bestimmung auf die Einordnung der
Situationen, bei welchen Schwarz am Zug ist, geachtet werden. Da beim
spÃ¤teren Verwenden der KI die ZÃ¼ge des schwarzen Spielers nicht
beeinflusst werden kÃ¶nnen, muss jeder mÃ¶gliche Zug einer Situation in
\(S_{n+1}\) mit \(n \% 2 = 0\) zu einer Situation aus \(S_n\) fÃ¼hren.
Diese ÃberprÃ¼fung wird mit der Funktion
\texttt{check\_black\_determinism} durchgefÃ¼hrt. Da die ZÃ¼ge von WeiÃ
gezielt gewÃ¤hlt werden kÃ¶nnen, ist diese ÃberprÃ¼fung bei \(n \% 2 = 1\)
nicht nÃ¶tig.

AuÃerdem mÃ¼ssen bei der DurchfÃ¼hrung des Algorithmus weitere Aspekte
berÃ¼cksichtigt werden: 
\begin{itemize}
	\item Da Bauern nur in eine Richtung laufen kÃ¶nnen,
	mÃ¼ssen die rÃ¼ckwÃ¤rts Schritte eines Bauern manuell durchgefÃ¼hrt werden.
	Bauern werden daher im ersten Schritt ignoriert. 
	\item Bauern, die die oberste Reihe des Spielfeldes erreichen, kÃ¶nnen zu einer anderen Figur
	eingetauscht werden. Dieser Schritt wird nicht durch die Pseudo-Legal-Moves abgedeckt, daher wird, sollte sich eine KÃ¶nigin in der obersten Reihe befinden, diese manuell durch einen Bauern ersetzt.
\end{itemize}

Die Umsetzung erfolgt durch die Funktion \texttt{previous\_states}. Alle
Funktionsparameter kÃ¶nnen aus der nachfolgenden Liste entnommen werden:

\begin{itemize}
\tightlist
\item
  \texttt{used\_boards}: Die Menge aller bereits einem \(n\)
  zugeordneten Situationen, welche nicht noch einmal beachtet werden
  sollen.
\item
  \texttt{iteration\_count}: \(n\) des \(S_n\), welches gerade berechnet
  wird.
\item
  \texttt{user\_wants\_pawn}: Ein Flag, welches steuert, ob spezifische
  Bewegungen des Bauern berechnet werden sollen.
\item
  \texttt{uniques}: Die Situationen, welche als Ursprung der Spiegelung
  verwendet werden.
\end{itemize}

Der Algorithmus zur Bestimmung der Menge \(S_{n+1}\) wird im folgenden
Abschnitt beschrieben. Um die Funktion Ã¼bersichtlicher zu halten, wurden
teile des Algorithmus in die Funktion \texttt{moves} Ã¼bertragen.

\begin{itemize}
\tightlist
\item
  Ãber die Uniques (ungespiegelte Situationen) iterieren.

  \begin{itemize}
  \tightlist
  \item
    Den Spieler, welcher am Zug ist, wechseln (Da, um im aktuellen
    Zustand anzukommen, der andere Spieler einen Zug gemacht hat)
  \item
    Alle Positionen mit Bauern berechnen
  \item
    Alle pseudo-legalen Bewegungen mittels der Funktion
    \texttt{regular\_moves} durchfÃ¼hren. Hierbei werden keine ZÃ¼ge der
    Bauern beachtet. Die technische Umsetzung wird in der Dokumentation
    der Funktion erklÃ¤rt.
  \item
    Wenn die Bewegungen von Bauern abgebildet werden mÃ¼ssen:

    \begin{itemize}
    \tightlist
    \item
      Bauern manuell einen Schritt ``nach hinten'' setzen.
    \item
      ÃberprÃ¼fen, ob eine Dame in der obersten Reihe durch einen Bauern
      in der vorletzten ersetzt werden muss.
    \item
      Die technische Umsetzung dieser Aktionen wird in der Dokumentation
      der Funktionen \texttt{pawn\_moves} und
      \texttt{replace\_queen\_with\_pawn} erklÃ¤rt.
    \end{itemize}
  \item
    Den Spieler, welcher ursprÃ¼nglich am Zug war, wiederherstellen.
  \item
    Wenn \((n+1) \% 2 = 0\) Ã¼berprÃ¼fen, ob alle zuvor berechneten Boards
    mit allen Moves in \(S_n\) enden.
  \end{itemize}
\end{itemize}

AuÃerdem mÃ¼ssen bei der DurchfÃ¼hrung des Algorithmus weitere Aspekte
berÃ¼cksichtigt werden:

\begin{itemize}
\tightlist
\item
  Da Bauern nur in eine Richtung laufen kÃ¶nnen, mÃ¼ssen die rÃ¼ckwÃ¤rts
  Schritte eines Bauern manuell durchgefÃ¼hrt werden. Bauern werden daher
  im ersten Schritt ignoriert.
\item
  Bauern, die die oberste Reihe des Spielfeldes erreichen, kÃ¶nnen zu
  einer anderen Figur eingetauscht werden. Dieser Schritt wird nicht
  durch die Pseudo-Legal-Moves abgedeckt, daher wird, sollte sich eine
  KÃ¶nigin in der obersten Reihe befinden, diese manuell durch einen
  Bauern ersetzt.
\end{itemize}

Die Funktion bestimmt die Menge \(S_{n+1}\), die Menge der bekannten
Boards als Tupel \texttt{used\_boards} und die ungespiegelten Origniale
aus \(n+1\) \texttt{s\_n1\_uniques}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{previous\PYZus{}states}\PY{p}{(}\PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{iteration\PYZus{}count}\PY{p}{,} \PY{n}{user\PYZus{}wants\PYZus{}pawn}\PY{p}{,} \PY{n}{uniques}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{}variables}
    \PY{n}{s\PYZus{}n1} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{s\PYZus{}n1\PYZus{}tuples} \PY{o}{=} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}
    \PY{n}{s\PYZus{}n1\PYZus{}uniques} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{s\PYZus{}n1\PYZus{}uniques\PYZus{}tuples} \PY{o}{=} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}

    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{uniques}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{n}{status} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Calculating S}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{iteration\PYZus{}count}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ \PYZhy{} Board }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ of }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{uniques}\PY{p}{)}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ from S}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{iteration\PYZus{}count}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}
        \PY{n}{clear\PYZus{}output}\PY{p}{(}\PY{n}{wait}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{status}\PY{p}{)}

        \PY{c+c1}{\PYZsh{} Copy current board and invert the player}
        \PY{n}{chess\PYZus{}board} \PY{o}{=} \PY{n}{uniques}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{p}{)}
        \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn} \PY{o}{=} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn} \PY{o}{\PYZca{}} \PY{k+kc}{True}

        \PY{c+c1}{\PYZsh{} Find all Pawns}
        \PY{n}{pawn\PYZus{}positions} \PY{o}{=} \PY{n}{find\PYZus{}pawns}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} try moves and check if they lead to new boards}
        \PY{n}{s\PYZus{}n1}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}tuples}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}uniques}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}uniques\PYZus{}tuples} \PY{o}{=} \PY{n}{moves}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}tuples}\PY{p}{,} \PY{n}{pawn\PYZus{}positions}\PY{p}{,} \PY{n}{user\PYZus{}wants\PYZus{}pawn}\PY{p}{,} \PY{n}{s\PYZus{}n1}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}uniques}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}uniques\PYZus{}tuples}\PY{p}{)}
            

        \PY{c+c1}{\PYZsh{} Restore the original state of the board}
        \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn} \PY{o}{=} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn} \PY{o}{\PYZca{}} \PY{k+kc}{True}
        
    \PY{c+c1}{\PYZsh{} Only needed for Black\PYZhy{}Moves}
    \PY{k}{if} \PY{n}{iteration\PYZus{}count} \PY{o}{\PYZpc{}} \PY{l+m+mi}{2} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{n}{clear\PYZus{}output}\PY{p}{(}\PY{n}{wait}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Calculating S}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{iteration\PYZus{}count}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ \PYZhy{} Checking Black Moves for determinism}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        
        \PY{n}{s\PYZus{}n1}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}tuples}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}uniques} \PY{o}{=} \PY{n}{check\PYZus{}black\PYZus{}determinism}\PY{p}{(}\PY{n}{s\PYZus{}n1}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}uniques\PYZus{}tuples}\PY{p}{)}

    \PY{n}{clear\PYZus{}output}\PY{p}{(}\PY{n}{wait}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Done with S}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{iteration\PYZus{}count}\PY{p}{)}\PY{p}{)}
    \PY{k}{return} \PY{n}{s\PYZus{}n1}\PY{p}{,} \PY{n}{used\PYZus{}boards} \PY{o}{|} \PY{n}{s\PYZus{}n1\PYZus{}tuples}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}uniques}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{hilfsfunktionen-fuxfcr-die-berechnung}{%
\subsection{Hilfsfunktionen fÃ¼r die
Berechnung}\label{hilfsfunktionen-fuxfcr-die-berechnung}}

Die folgenden Funktionen werden zur Berechnung der previous\_states
verwendet. Sie Ã¼bernehmen dabei diverse Aufgaben wie das DurchfÃ¼hren von
regulÃ¤ren Moves oder das ``manuelle'' Versetzen von Figuren, um eine
andere Situation zu generieren.

    Die Funktion \texttt{moves} fÃ¼hrt fÃ¼r eine Situation
\texttt{chess\_board} zunÃ¤chst ZÃ¼ge mit allen Figuren auÃer dem Bauern
durch. Wenn der Nutzer einen Bauern in seiner Konfiguration angegeben
hat, werden auch BauernzÃ¼ge sowie der Tausch Dame zu Bauer durchgefÃ¼hrt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{moves}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}tuples}\PY{p}{,} \PY{n}{pawn\PYZus{}positions}\PY{p}{,} \PY{n}{user\PYZus{}wants\PYZus{}pawn}\PY{p}{,} \PY{n}{s\PYZus{}n1}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}uniques}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}uniques\PYZus{}tuples}\PY{p}{)}\PY{p}{:}
    \PY{n}{tmp\PYZus{}n1}\PY{p}{,} \PY{n}{tmp\PYZus{}n1\PYZus{}tuples}\PY{p}{,} \PY{n}{tmp\PYZus{}uniques}\PY{p}{,} \PY{n}{tmp\PYZus{}uniques\PYZus{}tuples} \PY{o}{=} \PY{n}{regular\PYZus{}moves}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}tuples}\PY{p}{,} \PY{n}{pawn\PYZus{}positions}\PY{p}{,} \PY{n}{user\PYZus{}wants\PYZus{}pawn}\PY{p}{)}
    \PY{n}{s\PYZus{}n1} \PY{o}{+}\PY{o}{=} \PY{n}{tmp\PYZus{}n1}
    \PY{n}{s\PYZus{}n1\PYZus{}tuples} \PY{o}{|}\PY{o}{=} \PY{n}{tmp\PYZus{}n1\PYZus{}tuples}
    \PY{n}{s\PYZus{}n1\PYZus{}uniques} \PY{o}{+}\PY{o}{=} \PY{n}{tmp\PYZus{}uniques}
    \PY{n}{s\PYZus{}n1\PYZus{}uniques\PYZus{}tuples} \PY{o}{|}\PY{o}{=} \PY{n}{tmp\PYZus{}uniques\PYZus{}tuples}

    \PY{k}{if} \PY{n}{user\PYZus{}wants\PYZus{}pawn} \PY{o+ow}{and} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} Push all pawns one row back and check if this leads to new boards}
        \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{pawn\PYZus{}positions}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n}{tmp\PYZus{}list}\PY{p}{,} \PY{n}{tmp\PYZus{}set} \PY{o}{=} \PY{n}{pawn\PYZus{}moves}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}tuples}\PY{p}{)}
            \PY{n}{s\PYZus{}n1} \PY{o}{+}\PY{o}{=} \PY{n}{tmp\PYZus{}list}
            \PY{n}{s\PYZus{}n1\PYZus{}tuples} \PY{o}{|}\PY{o}{=} \PY{n}{tmp\PYZus{}set}
            \PY{n}{s\PYZus{}n1\PYZus{}uniques} \PY{o}{+}\PY{o}{=} \PY{n}{tmp\PYZus{}list}
            \PY{n}{s\PYZus{}n1\PYZus{}uniques\PYZus{}tuples} \PY{o}{|}\PY{o}{=} \PY{n}{tmp\PYZus{}set}
        
        \PY{c+c1}{\PYZsh{} Exchange Queens with Pawns}
        \PY{n}{queen\PYZus{}positions} \PY{o}{=} \PY{n}{check\PYZus{}top\PYZus{}row\PYZus{}for\PYZus{}queen}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{)}
        \PY{k}{if} \PY{n}{queen\PYZus{}positions}\PY{p}{:}
            \PY{n}{tmp\PYZus{}list}\PY{p}{,} \PY{n}{tmp\PYZus{}set} \PY{o}{=} \PY{n}{replace\PYZus{}queen\PYZus{}with\PYZus{}pawn}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}tuples}\PY{p}{,} \PY{n}{queen\PYZus{}positions}\PY{p}{)}
            \PY{n}{s\PYZus{}n1} \PY{o}{+}\PY{o}{=} \PY{n}{tmp\PYZus{}list}
            \PY{n}{s\PYZus{}n1\PYZus{}tuples} \PY{o}{|}\PY{o}{=} \PY{n}{tmp\PYZus{}set}
            \PY{n}{s\PYZus{}n1\PYZus{}uniques} \PY{o}{+}\PY{o}{=} \PY{n}{tmp\PYZus{}list}
            \PY{n}{s\PYZus{}n1\PYZus{}uniques\PYZus{}tuples} \PY{o}{|}\PY{o}{=} \PY{n}{tmp\PYZus{}set}
            
    \PY{k}{return} \PY{n}{s\PYZus{}n1}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}tuples}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}uniques}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}uniques\PYZus{}tuples}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{regular\_moves} fÃ¼hrt fÃ¼r eine Ã¼bergebene Situation
\texttt{chess\_board} alle \texttt{pseudo\_legal\_moves} durch, um
mÃ¶gliche vorhergehende Situationen zu berechnen.\\
Pseudo-Legale-ZÃ¼ge sind ZÃ¼ge, welche die Figuren auf eine Art bewegen,
die der Figur gestattet ist, aber unter UmstÃ¤nden in eine nicht legale
Spielsituation fÃ¼hrt. Diese werden verwendet, da nur weil der Move von
\(S_{n+1}\) zu \(S_n\) legal ist, der Zug umgekehrt dies nicht sein
muss.

Ein simples Beispiel: Situation \(S_n\): Ein KÃ¶nig befindet sich ein
Feld von einem Schach entfernt.\\
Diese Position kann erreicht worden sein, da der KÃ¶nig von einer
Position in \(S_{n+1}\) sich aus diesem Schach herausbewegt hat. Der Zug
``in das Schach'', wÃ¤re jedoch nicht legal, weshalb ein Move aus der
Liste der \texttt{pseudo\_legal\_moves} zur Berechnung genommen werden
muss. Dies funktioniert nicht fÃ¼r Bauern, da ein Schritt nach ``hinten''
keine Bewegung ist, welche der Figur zusteht.

Die Funktion Ã¼berprÃ¼ft jeden Zug, welcher in der Situation mÃ¶glich ist.
Wenn die errechnete Situation valide und noch nicht verwendet (Ã¼berprÃ¼ft
durch EintrÃ¤ge in \texttt{used\_boards} und \texttt{s\_n1\_tuples}) ist,
wird sie den RÃ¼ckgabe-Variablen angefÃ¼gt. Wenn sich keine Bauern auf dem
Spielfeld befinden (\texttt{user\_wants\_pawn}), dann kÃ¶nnen die
Situationen gespiegelt werden, um weiteren Rechenaufwand zu reduzieren.
Diese Spiegelung findet durch eine Iteration Ã¼ber die spÃ¤ter definierten
Swap\_Types statt. AnschlieÃend wird mit der Funktion \texttt{mirror}
die Spiegelung bestimmt, die ValiditÃ¤t der Situation Ã¼berprÃ¼ft und
ebenfalls an das Ergebnis angefÃ¼gt.

Nach Abschluss der Berechnungen gibt die Funktion die Liste alle neuen
Situationen (ungespiegelt \texttt{uniques} und gespiegelt
\texttt{new\_boards}) sowie deren Tupel-ReprÃ¤sentation wieder.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{regular\PYZus{}moves}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}tuples}\PY{p}{,} \PY{n}{pawn\PYZus{}positions}\PY{p}{,} \PY{n}{user\PYZus{}wants\PYZus{}pawn}\PY{p}{)}\PY{p}{:}
    \PY{n}{new\PYZus{}boards} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{new\PYZus{}tuples} \PY{o}{=} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}
    \PY{n}{new\PYZus{}uniques} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{new\PYZus{}uniques\PYZus{}tuples} \PY{o}{=} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}
    \PY{k}{for} \PY{n}{pLMove} \PY{o+ow}{in} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{pseudo\PYZus{}legal\PYZus{}moves}\PY{p}{:}
        \PY{k}{if} \PY{n}{chess}\PY{o}{.}\PY{n}{square\PYZus{}name}\PY{p}{(}\PY{n}{pLMove}\PY{o}{.}\PY{n}{from\PYZus{}square}\PY{p}{)} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{pawn\PYZus{}positions}\PY{p}{:}
            
            \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{push}\PY{p}{(}\PY{n}{pLMove}\PY{p}{)}
            
            \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn} \PY{o}{=} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn} \PY{o}{\PYZca{}} \PY{k+kc}{True}
            \PY{k}{if} \PY{o+ow}{not} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{is\PYZus{}valid}\PY{p}{(}\PY{p}{)} \PY{o+ow}{or} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{outcome}\PY{p}{(}\PY{p}{)} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
                \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn} \PY{o}{=} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn} \PY{o}{\PYZca{}} \PY{k+kc}{True}
                \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}
                \PY{k}{continue}
                
            \PY{c+c1}{\PYZsh{} If the new board is found in S, it can be reached in one step}
            \PY{n}{tuple\PYZus{}rep} \PY{o}{=} \PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{,}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}
            \PY{k}{if} \PY{n}{tuple\PYZus{}rep} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{used\PYZus{}boards} \PY{o+ow}{and} \PY{n}{tuple\PYZus{}rep} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{s\PYZus{}n1\PYZus{}tuples} \PY{o+ow}{and} \PY{n}{tuple\PYZus{}rep} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{new\PYZus{}tuples}\PY{p}{:}               
                \PY{n}{new\PYZus{}uniques}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{p}{)}\PY{p}{)}
                \PY{n}{new\PYZus{}uniques\PYZus{}tuples}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{tuple\PYZus{}rep}\PY{p}{)}
                
                \PY{n}{new\PYZus{}boards}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{p}{)}\PY{p}{)}
                \PY{n}{new\PYZus{}tuples}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{tuple\PYZus{}rep}\PY{p}{)}
                
                \PY{k}{if} \PY{o+ow}{not} \PY{n}{user\PYZus{}wants\PYZus{}pawn}\PY{p}{:}
                    \PY{k}{for} \PY{n}{swtype} \PY{o+ow}{in} \PY{n}{Swap\PYZus{}Type}\PY{p}{:}
                        \PY{n}{mirrored\PYZus{}board} \PY{o}{=} \PY{n}{mirror}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{,} \PY{n}{swtype}\PY{p}{)}
                        \PY{n}{tuple\PYZus{}rep\PYZus{}mir} \PY{o}{=} \PY{p}{(}\PY{n}{mirrored\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{,}\PY{n}{mirrored\PYZus{}board}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}
                        \PY{k}{if} \PY{n}{tuple\PYZus{}rep\PYZus{}mir} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{used\PYZus{}boards} \PY{o+ow}{and} \PY{n}{tuple\PYZus{}rep\PYZus{}mir} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{s\PYZus{}n1\PYZus{}tuples} \PY{o+ow}{and} \PY{n}{tuple\PYZus{}rep\PYZus{}mir} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{new\PYZus{}tuples}\PY{p}{:}
                            \PY{n}{new\PYZus{}boards}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{mirrored\PYZus{}board}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{p}{)}\PY{p}{)}
                            \PY{n}{new\PYZus{}tuples}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{tuple\PYZus{}rep\PYZus{}mir}\PY{p}{)}
            \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn} \PY{o}{=} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn} \PY{o}{\PYZca{}} \PY{k+kc}{True}
            \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}
    
    \PY{k}{return} \PY{n}{new\PYZus{}boards}\PY{p}{,} \PY{n}{new\PYZus{}tuples}\PY{p}{,} \PY{n}{new\PYZus{}uniques}\PY{p}{,} \PY{n}{new\PYZus{}uniques\PYZus{}tuples}
\end{Verbatim}
\end{tcolorbox}

    Wie zuvor bereits erwÃ¤hnt, ermÃ¶glicht die quadratische Natur des
Schachbrettes es das Spielbrett zu spiegeln / rotieren und weitere
Situationen zu erhalten.

ZunÃ¤chst wird ein Enum erstellt, welches es ermÃ¶glicht Ã¼ber die Arten
der Figurenvertauschungen zu iterieren. \texttt{Swap\_Type} Ã¼bersetzt zu
einem String, welcher im nÃ¤chsten Schritt als Key fÃ¼r ein Dictionary
verwendet wird.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{Swap\PYZus{}Type}\PY{p}{(}\PY{n}{Enum}\PY{p}{)}\PY{p}{:}
    \PY{n}{VERTICAL} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{vertical}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{HORIZONTAL} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{horizontal}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{ROTATE\PYZus{}RIGHT} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rotate\PYZus{}right}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{ROTATE\PYZus{}180} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rotate\PYZus{}180}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{ROTATE\PYZus{}LEFT} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rotate\PYZus{}left}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}
\end{tcolorbox}

    FÃ¼r den Tausch wird Ã¼ber jede Figur iteriert und diese an die
entsprechende Position gesetzt. Das Ergebnis wird als
\texttt{Board-Objekt} zurÃ¼ckgegeben.

Die Formeln zum Spiegeln und Rotieren der Spielsituationen wurden
\href{https://www.chessprogramming.org/Flipping_Mirroring_and_Rotating}{dieser
Quelle} entnommen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{mirror}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{sw\PYZus{}type} \PY{p}{:} \PY{n}{Swap\PYZus{}Type}\PY{p}{)}\PY{p}{:}
    \PY{n}{swaps} \PY{o}{=} \PY{p}{\PYZob{}}
        \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{vertical}\PY{l+s+s2}{\PYZdq{}} \PY{p}{:} \PY{p}{\PYZob{}}\PY{n}{x}\PY{p}{:}\PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{56} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{64}\PY{p}{)}\PY{p}{\PYZcb{}}\PY{p}{,}
        \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{horizontal}\PY{l+s+s2}{\PYZdq{}} \PY{p}{:} \PY{p}{\PYZob{}}\PY{n}{x}\PY{p}{:}\PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{7} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{64}\PY{p}{)}\PY{p}{\PYZcb{}}\PY{p}{,}
        \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rotate\PYZus{}right}\PY{l+s+s2}{\PYZdq{}} \PY{p}{:} \PY{p}{\PYZob{}}\PY{n}{x}\PY{p}{:}\PY{p}{(}\PY{p}{(}\PY{p}{(}\PY{n}{x} \PY{o}{\PYZgt{}\PYZgt{}} \PY{l+m+mi}{3}\PY{p}{)} \PY{o}{|} \PY{p}{(}\PY{n}{x} \PY{o}{\PYZlt{}\PYZlt{}} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)} \PY{o}{\PYZam{}} \PY{l+m+mi}{63}\PY{p}{)} \PY{o}{\PYZca{}} \PY{l+m+mi}{56} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{64}\PY{p}{)}\PY{p}{\PYZcb{}}\PY{p}{,}
        \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rotate\PYZus{}180}\PY{l+s+s2}{\PYZdq{}} \PY{p}{:} \PY{p}{\PYZob{}}\PY{n}{x} \PY{p}{:} \PY{n}{x} \PY{o}{\PYZca{}} \PY{l+m+mi}{63} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{64}\PY{p}{)}\PY{p}{\PYZcb{}}\PY{p}{,}
        \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rotate\PYZus{}left}\PY{l+s+s2}{\PYZdq{}} \PY{p}{:} \PY{p}{\PYZob{}}\PY{n}{x} \PY{p}{:} \PY{p}{(}\PY{p}{(}\PY{p}{(}\PY{n}{x} \PY{o}{\PYZgt{}\PYZgt{}} \PY{l+m+mi}{3}\PY{p}{)} \PY{o}{|} \PY{p}{(}\PY{n}{x} \PY{o}{\PYZlt{}\PYZlt{}} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)} \PY{o}{\PYZam{}} \PY{l+m+mi}{63}\PY{p}{)} \PY{o}{\PYZca{}} \PY{l+m+mi}{7} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{64}\PY{p}{)}\PY{p}{\PYZcb{}}
    \PY{p}{\PYZcb{}}
    
    \PY{n}{swapped\PYZus{}board} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Board}\PY{p}{(}\PY{p}{)}
    \PY{n}{swapped\PYZus{}board}\PY{o}{.}\PY{n}{clear}\PY{p}{(}\PY{p}{)}
    \PY{n}{swapped\PYZus{}board}\PY{o}{.}\PY{n}{turn} \PY{o}{=} \PY{n}{board}\PY{o}{.}\PY{n}{turn}

    \PY{k}{for} \PY{n}{position}\PY{p}{,} \PY{n}{piece} \PY{o+ow}{in} \PY{n}{board}\PY{o}{.}\PY{n}{piece\PYZus{}map}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
        \PY{n}{swapped\PYZus{}board}\PY{o}{.}\PY{n}{set\PYZus{}piece\PYZus{}at}\PY{p}{(}\PY{n}{swaps}\PY{p}{[}\PY{n}{sw\PYZus{}type}\PY{o}{.}\PY{n}{value}\PY{p}{]}\PY{p}{[}\PY{n}{position}\PY{p}{]}\PY{p}{,} \PY{n}{piece}\PY{p}{)}
    
    \PY{k}{return} \PY{n}{swapped\PYZus{}board}
\end{Verbatim}
\end{tcolorbox}

    Befinden sich Bauern in der Situation, mÃ¼ssen diese manuell platziert
werden, da fÃ¼r diese auch in den \texttt{pseudo\_legal\_moves} nur die
ZÃ¼ge \(S_n \rightarrow S_{(n+1)}\) aufgefÃ¼hrt sind. Die Funktion
\texttt{pawn\_moves} erfÃ¼llt diese Anforderung. Ãhnlich wie die Funktion
\texttt{regular\_moves} werden fÃ¼r eine Situation \texttt{chess\_board}
alle Situationen berechnet, welche durch Bewegung eines Bauerns zu
\texttt{chess\_board} werden. HierfÃ¼r wird Ã¼ber alle Bauern auf dem
Spielfeld iteriert, diese entfernt und auf das Feld mit dem Index
\(n-8\) wieder gesetzt. Da eine Reihe 8 Felder hat, hat das Feld in
derselben Linie aber vorherigen Reihe den Index 8 geringer. Auch diese
Situationen werden sowohl auf ValiditÃ¤t als auch bisheriges Vorkommen
Ã¼berprÃ¼ft, bevor sie den RÃ¼ckgabevariablen angefÃ¼gt werden. Das
Ã¼bergebene Objekt wird zu seinem Ursprungszustand zurÃ¼ckgefÃ¼hrt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{pawn\PYZus{}moves}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}tuples}\PY{p}{)}\PY{p}{:}
    \PY{n}{new\PYZus{}boards} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{new\PYZus{}tuples} \PY{o}{=} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}
    \PY{n}{chess\PYZus{}board} \PY{o}{=} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{p}{)}
    
    \PY{k}{for} \PY{n}{pawn} \PY{o+ow}{in} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{pieces}\PY{p}{(}\PY{n}{chess}\PY{o}{.}\PY{n}{PAWN}\PY{p}{,} \PY{k+kc}{True}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{piece\PYZus{}at}\PY{p}{(}\PY{n}{pawn} \PY{o}{\PYZhy{}} \PY{l+m+mi}{8}\PY{p}{)} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
            \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{remove\PYZus{}piece\PYZus{}at}\PY{p}{(}\PY{n}{pawn}\PY{p}{)}
            \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{set\PYZus{}piece\PYZus{}at}\PY{p}{(}\PY{n}{pawn} \PY{o}{\PYZhy{}} \PY{l+m+mi}{8}\PY{p}{,} \PY{n}{chess}\PY{o}{.}\PY{n}{Piece}\PY{o}{.}\PY{n}{from\PYZus{}symbol}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{P}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
            \PY{k}{if} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{is\PYZus{}valid}\PY{p}{(}\PY{p}{)} \PY{o+ow}{and} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{outcome}\PY{p}{(}\PY{p}{)} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
                \PY{n}{tuple\PYZus{}rep} \PY{o}{=} \PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{,}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}
                \PY{k}{if} \PY{n}{tuple\PYZus{}rep} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{used\PYZus{}boards} \PY{o+ow}{and} \PY{n}{tuple\PYZus{}rep} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{s\PYZus{}n1\PYZus{}tuples}\PY{p}{:}
                    \PY{n}{new\PYZus{}boards}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{p}{)}\PY{p}{)}
                    \PY{n}{new\PYZus{}tuples}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{tuple\PYZus{}rep}\PY{p}{)}
            
    \PY{k}{return} \PY{n}{new\PYZus{}boards}\PY{p}{,} \PY{n}{new\PYZus{}tuples}
\end{Verbatim}
\end{tcolorbox}

    Ein Problem, das bei der Verwendung der RÃ¼ckwÃ¤rts-Analyse auftritt,
liegt in dem Szenario: ``KÃ¶nig und Bauer gegen KÃ¶nig''. Dieses Szenario
beinhaltet die Umwandlung des Bauerns, welcher die oberste Zeile
erreicht hat, in eine andere Figur (Dame, Turm, LÃ¤ufer, Springer). Da
die Dame die stÃ¤rkste Figur im Spiel ist, wird immer dieser Tausch
gewÃ¤hlt. Hat der Nutzer bei den weiÃen Figuren, welche sich in der
Situation sollen, einen Bauern angegeben, wurde dieser beim Errechnen
der Menge \(S_0\) durch eine KÃ¶nigin ersetzt.

FÃ¼r die Berechnung der idealen ZÃ¼ge muss der Bauer wieder in die
Situationen, welche sich in den \(S_n\) Mengen befinden, eingefÃ¼hrt
werden. Der Tausch eines Bauerns zu einer Dame kann nicht durch die
\texttt{pseudo\_legal\_moves} umgekehrt werden.

Die Funktion \texttt{check\_top\_row\_for\_queen} Ã¼berprÃ¼ft, ob ein
solcher Tausch mÃ¶glich ist. Sie erhÃ¤lt als Parameter eine Situation
\texttt{board}, fÃ¼r welches die Felder der obersten Zeile Ã¼berprÃ¼ft und
jedes zurÃ¼ckgegeben wird, auf dem sich eine Dame befindet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{check\PYZus{}top\PYZus{}row\PYZus{}for\PYZus{}queen}\PY{p}{(}\PY{n}{board}\PY{p}{)}\PY{p}{:}
    \PY{n}{return\PYZus{}list} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{56}\PY{p}{,} \PY{l+m+mi}{64}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n}{board}\PY{o}{.}\PY{n}{piece\PYZus{}type\PYZus{}at}\PY{p}{(}\PY{n}{i}\PY{p}{)} \PY{o}{==} \PY{n}{chess}\PY{o}{.}\PY{n}{QUEEN}\PY{p}{:}
            \PY{n}{return\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{i}\PY{p}{)}

    \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{return\PYZus{}list}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{k}{return} \PY{n}{return\PYZus{}list}
    \PY{k}{else}\PY{p}{:}
        \PY{k}{return} \PY{k+kc}{False}
\end{Verbatim}
\end{tcolorbox}

    Wurden mittels der vorhergehenden Funktion Damen in der obersten Zeile
gefunden, ersetzt \texttt{replace\_queen\_with\_pawn} alle diese
Positionen (\texttt{toprow\_queen\_positions}) durch einen Bauern in der
vorletzten Zeile. Es wird Ã¼ber die Ã¼bergebenen Positionen von Damen in
der obersten Reihe iteriert, diese entfernt und in der Reihe davor (Feld
Index um 8 verringert) ein Bauer platziert. Wenn die Situation ein
valides Schachbrett darstellt, wird sie an die RÃ¼ckgabeliste angefÃ¼gt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{replace\PYZus{}queen\PYZus{}with\PYZus{}pawn}\PY{p}{(}\PY{n}{orig\PYZus{}board}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}tuples}\PY{p}{,} \PY{n}{toprow\PYZus{}queen\PYZus{}positions}\PY{p}{)}\PY{p}{:}
    \PY{n}{new\PYZus{}boards} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{new\PYZus{}tuples} \PY{o}{=} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}
    
    \PY{k}{for} \PY{n}{square} \PY{o+ow}{in} \PY{n}{toprow\PYZus{}queen\PYZus{}positions}\PY{p}{:}
        \PY{n}{chess\PYZus{}board} \PY{o}{=} \PY{n}{orig\PYZus{}board}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{p}{)}
        \PY{k}{if} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{piece\PYZus{}at}\PY{p}{(}\PY{n}{square} \PY{o}{\PYZhy{}} \PY{l+m+mi}{8}\PY{p}{)} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
            \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{remove\PYZus{}piece\PYZus{}at}\PY{p}{(}\PY{n}{square}\PY{p}{)}
            \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{set\PYZus{}piece\PYZus{}at}\PY{p}{(}\PY{n}{square} \PY{o}{\PYZhy{}} \PY{l+m+mi}{8}\PY{p}{,} \PY{n}{chess}\PY{o}{.}\PY{n}{Piece}\PY{o}{.}\PY{n}{from\PYZus{}symbol}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{P}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
            \PY{k}{if} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{is\PYZus{}valid}\PY{p}{(}\PY{p}{)} \PY{o+ow}{and} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{outcome}\PY{p}{(}\PY{p}{)} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
                \PY{n}{tuple\PYZus{}rep} \PY{o}{=} \PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{,}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}
                \PY{k}{if} \PY{n}{tuple\PYZus{}rep} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{used\PYZus{}boards} \PY{o+ow}{and} \PY{n}{tuple\PYZus{}rep} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{s\PYZus{}n1\PYZus{}tuples}\PY{p}{:}
                    \PY{n}{new\PYZus{}boards}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{p}{)}\PY{p}{)}
                    \PY{n}{new\PYZus{}tuples}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{tuple\PYZus{}rep}\PY{p}{)}
            \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{remove\PYZus{}piece\PYZus{}at}\PY{p}{(}\PY{n}{square} \PY{o}{\PYZhy{}} \PY{l+m+mi}{8}\PY{p}{)}
            \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{set\PYZus{}piece\PYZus{}at}\PY{p}{(}\PY{n}{square}\PY{p}{,} \PY{n}{chess}\PY{o}{.}\PY{n}{Piece}\PY{o}{.}\PY{n}{from\PYZus{}symbol}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Q}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
    \PY{k}{return} \PY{n}{new\PYZus{}boards}\PY{p}{,} \PY{n}{new\PYZus{}tuples}
\end{Verbatim}
\end{tcolorbox}

    Da Bauern mittels der Funktion \texttt{pawn\_moves} gesondert behandelt
werden mÃ¼ssen, muss in \texttt{regular\_moves} verhindert werden, dass
ZÃ¼ge mit Bauern durchgefÃ¼hrt werden. HierfÃ¼r wird die Information
benÃ¶tigt, auf welchen Feldern sich ein Bauer befindet. Diese Information
wird durch die Funktion \texttt{find\_pawns} generiert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{find\PYZus{}pawns}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{)}\PY{p}{:}
    \PY{n}{result} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{k}{for} \PY{n}{pawn} \PY{o+ow}{in} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{pieces}\PY{p}{(}\PY{n}{chess}\PY{o}{.}\PY{n}{PAWN}\PY{p}{,} \PY{k+kc}{True}\PY{p}{)}\PY{p}{:}
            \PY{n}{result}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{chess}\PY{o}{.}\PY{n}{square\PYZus{}name}\PY{p}{(}\PY{n}{pawn}\PY{p}{)}\PY{p}{)}
    \PY{k}{return} \PY{n}{result}
\end{Verbatim}
\end{tcolorbox}

    Wenn mittels der KI eine Spielsituation ausgewertet wird, kann fÃ¼r jeden
Zug des weiÃen Spielers ein Zug ausgewÃ¤hlt werden. FÃ¼r die Situationen,
bei denen Schwarz am Zug ist, muss die KI alle mÃ¶glichen ZÃ¼ge auswerten
kÃ¶nnen. Da jedoch fÃ¼r einen spezifischen Zug, welcher eine Situation von
\(S_n\) in \(S_{n-1}\) fÃ¼hrt, dasselbe nicht fÃ¼r alle ZÃ¼ge gilt, welche
in der Situation mÃ¶glich sind, mÃ¼ssen die Situationen, bei welchen
Schwarz am Zug ist, besonders gefiltert werden. FÃ¼r jede Situation \(b\)
aus einem \(S_n\) mit \(n \, \% \, 2 = 0\) muss folglich gelten:\\
\[
b \in S_n \implies \forall m \in valid\_moves(b): b.push(m) \in S_{m} \land m < n
\] Wobei \texttt{valid\_moves} die Liste der legalen ZÃ¼ge fÃ¼r eine
Situation ist und \texttt{b.push(m)} die Situation beschreibt, welche
durch AusfÃ¼hren des Zuges \(m\) entsteht.

Die Funktion \texttt{check\_black\_determinism} stellt dies sicher. FÃ¼r
jede Situation in \texttt{s\_n1} wird jeder mÃ¶gliche legale Zug
ausgefÃ¼hrt und Ã¼berprÃ¼ft, ob die entstehende Situation in einer Menge
\(S_m\) mit \(m \leq n\) auffindbar ist. Nur wenn alle ZÃ¼ge diese
Bedingung erfÃ¼llen, wird das Objekt in die Liste \texttt{s\_n1\_tmp},
welche in der Funktion \texttt{previous\_states} die eigentliche Liste
\texttt{s\_n1} ersetzen wird, aufgenommen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{check\PYZus{}black\PYZus{}determinism}\PY{p}{(}\PY{n}{s\PYZus{}n1}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{uniques\PYZus{}n1\PYZus{}tuples}\PY{p}{)}\PY{p}{:}
    \PY{n}{s\PYZus{}n1\PYZus{}tmp} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{s\PYZus{}n1\PYZus{}tuples\PYZus{}tmp} \PY{o}{=} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}
    \PY{n}{uniques\PYZus{}n1\PYZus{}tmp} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    
    
    \PY{k}{for} \PY{n}{chess\PYZus{}board} \PY{o+ow}{in} \PY{n}{s\PYZus{}n1}\PY{p}{:}
        \PY{n}{include} \PY{o}{=} \PY{k+kc}{True}        
        \PY{k}{if} \PY{o+ow}{not} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{:}
            \PY{k}{for} \PY{n}{move} \PY{o+ow}{in} \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{legal\PYZus{}moves}\PY{p}{:}
                \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{push}\PY{p}{(}\PY{n}{move}\PY{p}{)}
                \PY{n}{tuple\PYZus{}rep} \PY{o}{=} \PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{,}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}
                \PY{k}{if} \PY{n}{tuple\PYZus{}rep} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{used\PYZus{}boards}\PY{p}{:}
                    \PY{n}{include} \PY{o}{=} \PY{k+kc}{False}
                \PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}
        \PY{k}{if} \PY{n}{include}\PY{p}{:}
            \PY{n}{s\PYZus{}n1\PYZus{}tmp}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{)}
            \PY{n}{s\PYZus{}n1\PYZus{}tuples\PYZus{}tmp}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{,}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}\PY{p}{)}
            \PY{n}{tuple\PYZus{}rep} \PY{o}{=} \PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{,}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}
            \PY{k}{if} \PY{n}{tuple\PYZus{}rep} \PY{o+ow}{in} \PY{n}{uniques\PYZus{}n1\PYZus{}tuples}\PY{p}{:}    
                \PY{n}{uniques\PYZus{}n1\PYZus{}tmp}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{)}
    
    \PY{k}{return} \PY{n}{s\PYZus{}n1\PYZus{}tmp}\PY{p}{,} \PY{n}{s\PYZus{}n1\PYZus{}tuples\PYZus{}tmp}\PY{p}{,} \PY{n}{uniques\PYZus{}n1\PYZus{}tmp}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{export-in-datei}{%
\subsection{Export in Datei}\label{export-in-datei}}

Nach erfolgreicher Berechnung einer \(S_n\) Menge werden die FENs der
Situationen in eine temporÃ¤re \texttt{.preConvert} Datei geschrieben.
Wurden alle \(S_n\) berechnet, wird die temporÃ¤re Datei in eine
\texttt{.chessAI} Datei fÃ¼r die Verwendung in der KI und eine
\texttt{.chessTest} fÃ¼r das Testen der Ergebnisse konvertiert.

    Damit keine Werte einer vergangenen Berechnung in der temporÃ¤ren Datei
vorliegen, muss zuerst eine leere \texttt{.preConvert} Datei erstellt
werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{create\PYZus{}empty\PYZus{}file}\PY{p}{(}\PY{n}{filename}\PY{p}{)}\PY{p}{:}
    \PY{n}{f} \PY{o}{=} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}Results/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.preConvert}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{w}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Zwischenergebnisse werden stetig mittels der
\texttt{append\_to\_file} Funktion an die zuvor erstellte
\texttt{.preConvert} Datei angehÃ¤ngt. Jede Zeile entspricht hierbei
einem \(n\) aus den \(S_n\) Mengen. FÃ¼r die Zwischenergebnisse werden
die FENs als JSON gespeichert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{append\PYZus{}to\PYZus{}file}\PY{p}{(}\PY{n}{s\PYZus{}n}\PY{p}{,} \PY{n}{filename}\PY{p}{)}\PY{p}{:}
    \PY{n}{s\PYZus{}n\PYZus{}ascii} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{k}{for} \PY{n}{board} \PY{o+ow}{in} \PY{n}{s\PYZus{}n}\PY{p}{:}
        \PY{n}{s\PYZus{}n\PYZus{}ascii}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{board}\PY{o}{.}\PY{n}{fen}\PY{p}{(}\PY{p}{)}\PY{p}{)}

    \PY{n}{f} \PY{o}{=} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}Results/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.preConvert}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{a}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{json}\PY{o}{.}\PY{n}{dumps}\PY{p}{(}\PY{n}{s\PYZus{}n\PYZus{}ascii}\PY{p}{)}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Nachdem die gesamte Sequenz aller \(n\) berechnet wurde, muss die
temporÃ¤re Datei in zwei Dateien zur Auswertung konvertiert werden. Die
\texttt{.chessAI} Datei enthÃ¤lt Mengen von Tupeln. Die
\texttt{.chessTest} Datei enthÃ¤lt die FENs, um in den Test-Szenarien
wieder Board-Objekte erstellen zu kÃ¶nnen.

Zuerst mÃ¼ssen die Informationen Ã¼ber die berechneten \(S_n\) Mengen aus
der \texttt{.preConvert} Datei gelesen werden. Die darin gespeicherten
FENs werden in einer Liste gespeichert und zusÃ¤tzlich zu Board-Objekten
instanziiert. Die Objekte werden in die zuvor bereits verwendete
Tupel-Darstellung gewandelt und in eine Menge eingefÃ¼gt.

Zum Speichern der Dateien wird aus EffizienzgrÃ¼nden das Modul
\texttt{pickle} verwendet, welches die Daten in BinÃ¤rdateien speichert.
Da die \texttt{.chessAI} Dateien gegebenenfalls an Nutzer der KI
verteilt werden mÃ¼ssen, werden diese zusÃ¤tzlich mit dem Modul
\texttt{ZipFile} komprimiert. Die \texttt{.chessTest} Dateien werden nur
zum Evaluieren der Ergebnisse verwendet und nicht an Nutzer verteilt.
Damit sie schneller eingelesen werden kÃ¶nnen, werden sie nicht
komprimiert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{convert\PYZus{}file}\PY{p}{(}\PY{n}{filename}\PY{p}{)}\PY{p}{:}
    \PY{n}{s\PYZus{}n\PYZus{}seq\PYZus{}fens} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{s\PYZus{}n\PYZus{}seq\PYZus{}tuples} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{f} \PY{o}{=} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}Results/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.preConvert}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rb}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{lines} \PY{o}{=} \PY{n}{f}\PY{o}{.}\PY{n}{readlines}\PY{p}{(}\PY{p}{)}
    \PY{n}{first} \PY{o}{=} \PY{k+kc}{True}
    \PY{k}{for} \PY{n}{line} \PY{o+ow}{in} \PY{n}{lines}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} First line is empty}
        \PY{k}{if} \PY{n}{first}\PY{p}{:}
            \PY{n}{first} \PY{o}{=} \PY{k+kc}{False}
            \PY{k}{continue}

        \PY{n}{tmp\PYZus{}list} \PY{o}{=} \PY{p}{[}\PY{p}{]}
        \PY{n}{tmp\PYZus{}set} \PY{o}{=} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}
        \PY{n}{tmp} \PY{o}{=} \PY{n}{json}\PY{o}{.}\PY{n}{loads}\PY{p}{(}\PY{n}{line}\PY{p}{)}

        \PY{k}{for} \PY{n}{fen} \PY{o+ow}{in} \PY{n}{tmp}\PY{p}{:}
            \PY{n}{tmp\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{fen}\PY{p}{)}
            \PY{n}{tmp\PYZus{}board} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Board}\PY{p}{(}\PY{n}{fen}\PY{p}{)}
            \PY{n}{tmp\PYZus{}set}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{p}{(}\PY{n}{tmp\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{,}\PY{n}{tmp\PYZus{}board}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}\PY{p}{)}
        \PY{n}{s\PYZus{}n\PYZus{}seq\PYZus{}fens}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{tmp\PYZus{}list}\PY{p}{)}
        \PY{n}{s\PYZus{}n\PYZus{}seq\PYZus{}tuples}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{tmp\PYZus{}set}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}

    \PY{n}{f} \PY{o}{=} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}Results/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.pickle}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{wb}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{pickle}\PY{o}{.}\PY{n}{dumps}\PY{p}{(}\PY{n}{s\PYZus{}n\PYZus{}seq\PYZus{}tuples}\PY{p}{)}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}
    
    \PY{n}{f} \PY{o}{=} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}Results/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.chessTest}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{wb}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{pickle}\PY{o}{.}\PY{n}{dumps}\PY{p}{(}\PY{n}{s\PYZus{}n\PYZus{}seq\PYZus{}fens}\PY{p}{)}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}
    
    \PY{k}{with} \PY{n}{ZipFile}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}Results/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{.chessAI}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{compression}\PY{o}{=}\PY{n}{ZIP\PYZus{}DEFLATED}\PY{p}{)} \PY{k}{as} \PY{n}{zipped}\PY{p}{:}
        \PY{n}{zipped}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}Results/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.pickle}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{filename}\PY{o}{+}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.pickle}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{k}{if} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{exists}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}Results/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.chessAI}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{o+ow}{and} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{exists}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}Results/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.pickle}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{:}
        \PY{n}{os}\PY{o}{.}\PY{n}{remove}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}Results/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.pickle}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} 

    \PY{k}{if} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{exists}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}Results/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.preConvert}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{:}
        \PY{n}{os}\PY{o}{.}\PY{n}{remove}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}Results/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.preConvert}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Mit den zuvor definierten Funktionen ist es nun mÃ¶glich, alle \(S_n\) zu
bestimmen. HierfÃ¼r wird die Funktion \texttt{previous\_states} solange
aufgerufen, bis keine Situationen fÃ¼r ein \(n+1\) mehr gefunden werden
und die Liste \(S_{n+1}\) leer ist.

Die Funktion \texttt{run} geht hierbei von einem \texttt{s\_n}, welches
zuvor bestimmt wurde, aus und durchlÃ¤uft diesen Prozess in einer
Schleife. Nach abgeschlossener Rechnung wird das Konvertieren der Datei
gestartet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{run}\PY{p}{(}\PY{n}{s\PYZus{}n}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{n}\PY{p}{,} \PY{n}{user\PYZus{}wants\PYZus{}pawn}\PY{p}{,} \PY{n}{filename}\PY{p}{,} \PY{n}{uniques}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{n} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{n}{append\PYZus{}to\PYZus{}file}\PY{p}{(}\PY{n}{s\PYZus{}n}\PY{p}{,} \PY{n}{filename}\PY{p}{)}

    \PY{k}{while} \PY{k+kc}{True}\PY{p}{:}
        \PY{n}{n} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
        \PY{n}{s\PYZus{}n}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{uniques} \PY{o}{=} \PY{n}{previous\PYZus{}states}\PY{p}{(}\PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{n}\PY{p}{,} \PY{n}{user\PYZus{}wants\PYZus{}pawn}\PY{p}{,} \PY{n}{uniques}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{n}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{: }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{s\PYZus{}n}\PY{p}{)}\PY{p}{)}\PY{p}{)}
        \PY{k}{if} \PY{o+ow}{not} \PY{n}{s\PYZus{}n}\PY{p}{:} \PY{c+c1}{\PYZsh{}an empty list is false}
           \PY{k}{break}
        \PY{n}{append\PYZus{}to\PYZus{}file}\PY{p}{(}\PY{n}{s\PYZus{}n}\PY{p}{,} \PY{n}{filename}\PY{p}{)}
        \PY{k}{del} \PY{n}{s\PYZus{}n}

    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Done}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{n+nb}{str}\PY{p}{(}\PY{n}{n}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ S\PYZhy{}Lists calculated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

    \PY{n}{convert\PYZus{}file}\PY{p}{(}\PY{n}{filename}\PY{p}{)}

    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{File converted}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{run\_from\_start} berechnet \(S_0\) und startet
anschlieÃend die Berechnung aller \(S_n\).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{run\PYZus{}from\PYZus{}start}\PY{p}{(}\PY{n}{user\PYZus{}supplied\PYZus{}pieces}\PY{p}{,} \PY{n}{filename}\PY{p}{)}\PY{p}{:}
    \PY{n}{user\PYZus{}wants\PYZus{}pawn} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Piece}\PY{o}{.}\PY{n}{from\PYZus{}symbol}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{P}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{o+ow}{in} \PY{n}{user\PYZus{}supplied\PYZus{}pieces}
    
    \PY{n}{s\PYZus{}0}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{uniques} \PY{o}{=} \PY{n}{setup\PYZus{}boards}\PY{p}{(}\PY{n}{user\PYZus{}supplied\PYZus{}pieces}\PY{p}{,} \PY{n}{user\PYZus{}wants\PYZus{}pawn}\PY{p}{)}
    \PY{n}{create\PYZus{}empty\PYZus{}file}\PY{p}{(}\PY{n}{filename}\PY{p}{)}
    \PY{n}{run}\PY{p}{(}\PY{n}{s\PYZus{}0}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{n}{user\PYZus{}wants\PYZus{}pawn}\PY{p}{,} \PY{n}{filename}\PY{p}{,} \PY{n}{uniques}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Wurde die Berechnung abgebrochen (z.B. durch einen Neustart des
Computers) kann die Funktion \texttt{resume\_from\_file} den Zustand,
welcher in einer \texttt{.preConvert} Datei gespeichert wurde
wiederherstellen, und die Berechnung beim nÃ¤chsten \(n\) fortsetzen.
HierfÃ¼r werden alle bereits berechneten \(n\) in Objekte instanziiert
und die Tupel ReprÃ¤sentationen als bereits verwendete Situationen
(\texttt{used\_boards}) gespeichert. FÃ¼r das hÃ¶chste \(n\), werden die
Objekte behalten und der \texttt{run} Funktion Ã¼bergeben.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{resume\PYZus{}from\PYZus{}file}\PY{p}{(}\PY{n}{filename}\PY{p}{)}\PY{p}{:}
    \PY{n}{used\PYZus{}boards} \PY{o}{=} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}
    \PY{n}{s\PYZus{}n} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{count} \PY{o}{=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}

    \PY{n}{f} \PY{o}{=} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}Results/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.preConvert}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{r}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{lines} \PY{o}{=} \PY{n}{f}\PY{o}{.}\PY{n}{readlines}\PY{p}{(}\PY{p}{)}
    \PY{n}{first} \PY{o}{=} \PY{k+kc}{True}
    \PY{k}{for} \PY{n}{line} \PY{o+ow}{in} \PY{n}{lines}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} First line is empty}
        \PY{k}{if} \PY{n}{first}\PY{p}{:}
            \PY{n}{first} \PY{o}{=} \PY{k+kc}{False}
            \PY{k}{continue}

        \PY{n}{tmp\PYZus{}list} \PY{o}{=} \PY{p}{[}\PY{p}{]}
        \PY{n}{tmp\PYZus{}set} \PY{o}{=} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}
        \PY{n}{tmp} \PY{o}{=} \PY{n}{json}\PY{o}{.}\PY{n}{loads}\PY{p}{(}\PY{n}{line}\PY{p}{)}

        \PY{k}{for} \PY{n}{fen} \PY{o+ow}{in} \PY{n}{tmp}\PY{p}{:}
            \PY{n}{chess\PYZus{}board} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Board}\PY{p}{(}\PY{n}{fen}\PY{p}{)}
            \PY{n}{tmp\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{)}
            \PY{n}{tmp\PYZus{}set}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{,}\PY{n}{chess\PYZus{}board}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}\PY{p}{)}
        \PY{n}{s\PYZus{}n} \PY{o}{=} \PY{n}{tmp\PYZus{}list}
        \PY{n}{used\PYZus{}boards} \PY{o}{|}\PY{o}{=} \PY{n}{tmp\PYZus{}set}
        \PY{n}{count} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
    \PY{n}{f}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Starting at S}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{count}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ (}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{s\PYZus{}n}\PY{p}{)}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ Boards)}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    
    \PY{c+c1}{\PYZsh{} Adding a few Pawns to the result only slightly increases the file\PYZus{}size, and the value of user\PYZus{}wants\PYZus{}pawn is \PYZbs{}}
    \PY{c+c1}{\PYZsh{} currently not stored}
    \PY{n}{run}\PY{p}{(}\PY{n}{s\PYZus{}n}\PY{p}{,} \PY{n}{used\PYZus{}boards}\PY{p}{,} \PY{n}{count}\PY{p}{,} \PY{k+kc}{True}\PY{p}{,} \PY{n}{filename}\PY{p}{,} \PY{n}{s\PYZus{}n}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{konfigurations-variablen}{%
\subsection{Konfigurations Variablen}\label{konfigurations-variablen}}

FÃ¼r die Bestimmung der gewonnenen Spielbretter mÃ¼ssen nun die
Spielfiguren angegeben werden, fÃ¼r die die Endspiel-Datenbank berechnet
werden soll. HierfÃ¼r werden in der Liste \texttt{pieces\_to\_place} alle
Figuren aufgefÃ¼hrt. Die EintrÃ¤ge der Liste werden als Tupel bestehend
aus Figur und Farbe gespeichert. Bsp.:
\texttt{(chess.KING,\ chess.WHITE)} Die Reihenfolge oder Position der
Figur ist fÃ¼r die Berechnung irrelevant. Diese wird erst im nÃ¤chsten
Schritt (der Auswertung) benÃ¶tigt.

Der \texttt{FILENAME} wird fÃ¼r das Speichern der Ergebnisse verwendet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{WHITE\PYZus{}PIECES\PYZus{}TO\PYZus{}PLACE} \PY{o}{=} \PY{p}{[}\PY{n}{chess}\PY{o}{.}\PY{n}{Piece}\PY{o}{.}\PY{n}{from\PYZus{}symbol}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{P}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{]}

\PY{n}{FILENAME} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}seq\PYZus{}pawn}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{start-der-rechnung}{%
\subsection{Start der Rechnung}\label{start-der-rechnung}}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{o}{\PYZpc{}}\PY{n}{time}
\PY{n}{run\PYZus{}from\PYZus{}start}\PY{p}{(}\PY{n}{WHITE\PYZus{}PIECES\PYZus{}TO\PYZus{}PLACE}\PY{p}{,} \PY{n}{FILENAME}\PY{p}{)}
\PY{c+c1}{\PYZsh{}resume\PYZus{}from\PYZus{}file(FILENAME)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{spielen-gegen-die-ki}{%
\section{Spielen gegen die KI}\label{spielen-gegen-die-ki}}

    \hypertarget{vom-nutzer-zu-tuxe4tigende-einstellungen}{%
\subsection{Vom Nutzer zu tÃ¤tigende
Einstellungen}\label{vom-nutzer-zu-tuxe4tigende-einstellungen}}

Zur Erstellung eines individuellen Spielfeldes werden Dictionaries
verwendet. Diese verwenden jeweils als \texttt{key} die Figur, die auf
dem Spielfeld platziert werden soll. Als \texttt{value} nutzen die
EintrÃ¤ge jeweils eine Liste, die vom Nutzer mit den String-Bezeichnern
der Felder gefÃ¼llt werden sollen, auf denen die jeweilige Figur steht.
Die Bezeichner folgen hierbei dem Format, welches in Notebook
\texttt{01\_chess\_introduction} erklÃ¤rt wurde.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{WHITE\PYZus{}POSITIONS} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{chess}\PY{o}{.}\PY{n}{KING}\PY{p}{:}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{e1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                   \PY{n}{chess}\PY{o}{.}\PY{n}{QUEEN}\PY{p}{:}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a6}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                   \PY{n}{chess}\PY{o}{.}\PY{n}{ROOK}\PY{p}{:}\PY{p}{[}\PY{p}{]}\PY{p}{,}
                   \PY{n}{chess}\PY{o}{.}\PY{n}{BISHOP}\PY{p}{:}\PY{p}{[}\PY{p}{]}\PY{p}{,}
                   \PY{n}{chess}\PY{o}{.}\PY{n}{KNIGHT}\PY{p}{:}\PY{p}{[}\PY{p}{]}\PY{p}{,}
                   \PY{n}{chess}\PY{o}{.}\PY{n}{PAWN}\PY{p}{:}\PY{p}{[}\PY{p}{]}\PY{p}{\PYZcb{}}

\PY{n}{BLACK\PYZus{}POSITIONS} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{chess}\PY{o}{.}\PY{n}{KING}\PY{p}{:}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{e7}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                   \PY{n}{chess}\PY{o}{.}\PY{n}{QUEEN}\PY{p}{:}\PY{p}{[}\PY{p}{]}\PY{p}{,}
                   \PY{n}{chess}\PY{o}{.}\PY{n}{ROOK}\PY{p}{:}\PY{p}{[}\PY{p}{]}\PY{p}{,}
                   \PY{n}{chess}\PY{o}{.}\PY{n}{BISHOP}\PY{p}{:}\PY{p}{[}\PY{p}{]}\PY{p}{,}
                   \PY{n}{chess}\PY{o}{.}\PY{n}{KNIGHT}\PY{p}{:}\PY{p}{[}\PY{p}{]}\PY{p}{,}
                   \PY{n}{chess}\PY{o}{.}\PY{n}{PAWN}\PY{p}{:}\PY{p}{[}\PY{p}{]}\PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    Weiter muss der Nutzer angeben, welche vorher berechnete Spielsituation
er laden mÃ¶chte. HierfÃ¼r muss der Dateiname in einer globalen Variable
(ohne Dateiendung \texttt{.chessAI}) angegeben werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{FILE} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}seq\PYZus{}queen}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{logik-fuxfcr-die-interaktion-mit-der-spielsituation}{%
\subsection{Logik fÃ¼r die Interaktion mit der
Spielsituation}\label{logik-fuxfcr-die-interaktion-mit-der-spielsituation}}

Im folgenden Abschnitt sollen einige Hilfsfunktionen erklÃ¤rt werden,
welche fÃ¼r die Interaktion zwischen dem Nutzer Ã¼ber ein Jupyter Notebook
und der Spielsituation benÃ¶tigt werden.

Die Funktion \texttt{get\_occupied\_cells()} Ã¼bersetzt die zuvor
erstellten und vom Nutzer verÃ¤nderten \texttt{Position-Dictionaries} in
eine Liste, die alle \texttt{values} der Dictionaries, also besetzte
Felder enthÃ¤lt. Diese Liste wird benÃ¶tigt, um zu Ã¼berprÃ¼fen, ob die
Eingaben des Nutzers korrekte Zellen sind.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{get\PYZus{}occupied\PYZus{}cells}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n}{cells} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{k}{for} \PY{n}{values} \PY{o+ow}{in} \PY{n}{WHITE\PYZus{}POSITIONS}\PY{o}{.}\PY{n}{values}\PY{p}{(}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{value} \PY{o+ow}{in} \PY{n}{values}\PY{p}{:}
            \PY{n}{cells}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{value}\PY{p}{)}
    \PY{k}{for} \PY{n}{values} \PY{o+ow}{in} \PY{n}{BLACK\PYZus{}POSITIONS}\PY{o}{.}\PY{n}{values}\PY{p}{(}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{value} \PY{o+ow}{in} \PY{n}{values}\PY{p}{:}
            \PY{n}{cells}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{value}\PY{p}{)}
    \PY{k}{return} \PY{n}{cells}
\end{Verbatim}
\end{tcolorbox}

    Mit der Information von der vorherigen Funktion Ã¼bernimmt die Funktion
\texttt{check\_for\_correct\_cells()} die ÃberprÃ¼fung. Hierzu wird jeder
Wert in den eingegebenen Feldern in den Dictionaries
\texttt{WHITE\_POSITIONS} und \texttt{BLACK\_POSITIONS} auf Einhaltung
eines regulÃ¤ren Ausdrucks, welcher auf eine Kombination aus Buchstabe
und Zahl Ã¼berprÃ¼ft. Das Ergebnis wird in Form eines booleschen Werts
zurÃ¼ckgegeben.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{check\PYZus{}for\PYZus{}correct\PYZus{}cells}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n}{cells} \PY{o}{=} \PY{n}{get\PYZus{}occupied\PYZus{}cells}\PY{p}{(}\PY{p}{)}
    \PY{k}{for} \PY{n}{cell} \PY{o+ow}{in} \PY{n}{cells}\PY{p}{:}
        \PY{n}{x} \PY{o}{=} \PY{n}{re}\PY{o}{.}\PY{n}{search}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{[a\PYZhy{}h][1\PYZhy{}8]}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{cell}\PY{p}{)}
        \PY{k}{if} \PY{n}{x} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{cell}\PY{p}{)}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Value incorrect!}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{k}{return} \PY{k+kc}{False}
        \PY{k}{else}\PY{p}{:}
            \PY{k}{pass}
    \PY{k}{return} \PY{k+kc}{True}
\end{Verbatim}
\end{tcolorbox}

    Bevor die Figuren dem Objekt hinzugefÃ¼gt werden, werden sie in einem
Dictionary gesammelt, welches als \texttt{Piece-Map} verwendet wird.

Die Funktion \texttt{collect\_cells(color,\ pieces)} erstellt aus einem
Booleschen-Wert fÃ¼r die Spielerfarbe und einem Dictionary mit Figuren
und Spielfeldern eine Liste mit \texttt{Piece} Objekten, welche als
Index den Index des Spielfeldes verwendet. Diese Liste entspricht dem
Format, mit welchem Formationen von der Bibliothek geladen werden
kÃ¶nnen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{collect\PYZus{}cells}\PY{p}{(}\PY{n}{color}\PY{p}{,} \PY{n}{pieces}\PY{p}{)}\PY{p}{:}
    \PY{n}{occupied\PYZus{}cells} \PY{o}{=} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}
    \PY{k}{for} \PY{n}{piece\PYZus{}type}\PY{p}{,} \PY{n}{values} \PY{o+ow}{in} \PY{n}{pieces}\PY{p}{:}
            \PY{n}{piece} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Piece}\PY{p}{(}\PY{n}{piece\PYZus{}type}\PY{p}{,} \PY{n}{color}\PY{p}{)}
            \PY{k}{for} \PY{n}{value} \PY{o+ow}{in} \PY{n}{values}\PY{p}{:}
                \PY{n}{square} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{parse\PYZus{}square}\PY{p}{(}\PY{n}{value}\PY{p}{)}
                \PY{n}{occupied\PYZus{}cells}\PY{p}{[}\PY{n}{square}\PY{p}{]} \PY{o}{=} \PY{n}{piece}
            
    \PY{k}{return} \PY{n}{occupied\PYZus{}cells}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{create\_board()} fÃ¼llt das Schachbrett letztlich
mit den Figuren, die in den Dictionaries angegeben wurden. Als
RÃ¼ckgabewert gibt die Funktion das gefÃ¼llte Schachbrett als Objekt der
\texttt{chess} Library zurÃ¼ck. Hierzu werden die vorherigen Funktionen
verwendet, um die \texttt{Piece-Map} zu erstellen, diese auf das
Board-Objekt angewandt und auf ValiditÃ¤t Ã¼berprÃ¼ft. Ist das Board nicht
valide, wird ein Fehler ausgegeben.

Ein Problem, welches in Spielsituationen mit dem Turm auftritt, ist die
Berechtigung zu einer Rochade. Damit das Board als valide anerkannt
wird, werden die entsprechenden Flags mit der Funktion
\texttt{clean\_castling\_rights} korrekt gesetzt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{create\PYZus{}board}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n}{local\PYZus{}board} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Board}\PY{p}{(}\PY{p}{)}
    \PY{n}{occupied\PYZus{}cells} \PY{o}{=} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}
    \PY{k}{if} \PY{n}{check\PYZus{}for\PYZus{}correct\PYZus{}cells}\PY{p}{(}\PY{p}{)}\PY{p}{:}
        \PY{n}{occupied\PYZus{}cells} \PY{o}{|}\PY{o}{=} \PY{n}{collect\PYZus{}cells}\PY{p}{(}\PY{n}{chess}\PY{o}{.}\PY{n}{WHITE}\PY{p}{,} \PY{n}{WHITE\PYZus{}POSITIONS}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{)}
        \PY{n}{occupied\PYZus{}cells} \PY{o}{|}\PY{o}{=} \PY{n}{collect\PYZus{}cells}\PY{p}{(}\PY{n}{chess}\PY{o}{.}\PY{n}{BLACK}\PY{p}{,} \PY{n}{BLACK\PYZus{}POSITIONS}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{)}

        \PY{n}{local\PYZus{}board}\PY{o}{.}\PY{n}{set\PYZus{}piece\PYZus{}map}\PY{p}{(}\PY{n}{occupied\PYZus{}cells}\PY{p}{)}
        \PY{n}{local\PYZus{}board}\PY{o}{.}\PY{n}{castling\PYZus{}rights} \PY{o}{=} \PY{n}{local\PYZus{}board}\PY{o}{.}\PY{n}{clean\PYZus{}castling\PYZus{}rights}\PY{p}{(}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Herausfinden, weshalb momentan angegebenes Board invalid ist}
        \PY{k}{if} \PY{o+ow}{not} \PY{n}{local\PYZus{}board}\PY{o}{.}\PY{n}{is\PYZus{}valid}\PY{p}{(}\PY{p}{)}\PY{p}{:}
            \PY{n}{display}\PY{p}{(}\PY{n}{local\PYZus{}board}\PY{p}{)}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Specified lineup is invalid}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Default board created instead}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n}{local\PYZus{}board} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Board}\PY{p}{(}\PY{p}{)}
    \PY{k}{return} \PY{n}{local\PYZus{}board}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{import-der-daten}{%
\subsection{Import der Daten}\label{import-der-daten}}

FÃ¼r die Bestimmung der ZÃ¼ge der KI werden die \(S_n\) Mengen verwendet,
die im Notebook \texttt{calculation.ipynb} berechnet werden.\\
Eine ErklÃ¤rung worum es sich hierbei handelt, findet sich in diesem
Notebook. Die Ergebnisse der Berechnung werden mittels \texttt{pickle}
serialisiert und in einer ZIP-Datei komprimiert abgespeichert. Zur
Verwendung wird das Archiv entpackt und die Liste deserialisiert.
Weitere Informationen zum Inhalt der Datei befinden sich ebenfalls im
Notebook \texttt{calculation.ipynb}.

Die Funktion \texttt{load\_s\_n\_sequence(filename)} erhÃ¤lt den
Dateinamen (\texttt{filename}) als Parameter und gibt die Endspieldaten
zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{load\PYZus{}s\PYZus{}n\PYZus{}sequence}\PY{p}{(}\PY{n}{filename}\PY{p}{)}\PY{p}{:}
    \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}tuples} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{k}{with} \PY{n}{ZipFile}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}Results/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.chessAI}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{zipped}\PY{p}{:}
        \PY{k}{with} \PY{n}{zipped}\PY{o}{.}\PY{n}{open}\PY{p}{(}\PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.pickle}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{calculation}\PY{p}{:}
            \PY{n}{tmp} \PY{o}{=} \PY{n}{pickle}\PY{o}{.}\PY{n}{loads}\PY{p}{(}\PY{n}{calculation}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}\PY{p}{)}
            \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{tmp}\PY{p}{:}
                \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}tuples}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{item}\PY{p}{)}
    \PY{k}{return} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}tuples}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{den-besten-zug-fuxfcr-die-ki-ermitteln}{%
\subsection{Den besten Zug fÃ¼r die KI
ermitteln}\label{den-besten-zug-fuxfcr-die-ki-ermitteln}}

Um mit den berechneten Endspieldaten gegen einen Spieler zu gewinnen,
muss jeder Zug, den WeiÃ macht, optimal sein. Ein passender Zug fÃ¼r die
KI besteht darin die Situation von \(S_n\) in einen Zustand zu
Ã¼berfÃ¼hren, in dem sie sich in \(S_{n-1}\) befindet.

Die Funktion
\texttt{find\_next\_move(curr\_board,\ s\_index,\ s\_n\_sequence)}
bestimmt fÃ¼r ein Ã¼bergebenes Board-Objekt einen solchen Spielzug. Aus
EffizienzgrÃ¼nden wird zusÃ¤tzlich zum gefundenen Spielzug (\texttt{move})
der neue Wert fÃ¼r \(n\) zurÃ¼ckgegeben.

FÃ¼r diese Berechnung benÃ¶tigt \texttt{find\_next\_move} nachkommende
Argumente:
\begin{itemize}
	\item \texttt{curr\_board}: Das Board, fÃ¼r welches der nÃ¤chste
	Spielzug berechnet werden soll. 
	\item \texttt{s\_index}: Das \(n\) eines
	\(S_n\), in welchem sich \texttt{curr\_board} befindet. Wird aus
	EffizienzgrÃ¼nden Ã¼bergeben.
	\item \texttt{s\_n\_sequence}: Die Liste mit
	allen \(S_n\).
\end{itemize}

Kann kein Spielzug gefunden werden, gibt die Funktion den Wert -1
zurÃ¼ck.

Die fÃ¼r diesen Ablauf benÃ¶tigte Funktion
\texttt{find\_situation\_in\_sequence} wird im Notebook
\texttt{functions.ipynb} definiert und erklÃ¤rt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{find\PYZus{}next\PYZus{}move}\PY{p}{(}\PY{n}{curr\PYZus{}board}\PY{p}{,} \PY{n}{s\PYZus{}index}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence}\PY{p}{)}\PY{p}{:}
    \PY{n}{s\PYZus{}index\PYZus{}new} \PY{o}{=} \PY{n}{s\PYZus{}index} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}
    \PY{k}{for} \PY{n}{move} \PY{o+ow}{in} \PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n}{legal\PYZus{}moves}\PY{p}{:}
        \PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n}{push}\PY{p}{(}\PY{n}{move}\PY{p}{)}
        \PY{n}{curr\PYZus{}tupel} \PY{o}{=} \PY{p}{(}\PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{,} \PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}
        \PY{n}{\PYZus{}tmp} \PY{o}{=} \PY{n}{find\PYZus{}situation\PYZus{}in\PYZus{}sequence}\PY{p}{(}\PY{n}{curr\PYZus{}tupel}\PY{p}{,} \PY{p}{[}\PY{n}{s\PYZus{}n\PYZus{}sequence}\PY{p}{[}\PY{n}{s\PYZus{}index\PYZus{}new}\PY{p}{]}\PY{p}{]}\PY{p}{)}
        \PY{k}{if} \PY{n}{\PYZus{}tmp} \PY{o}{!=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{:}
            \PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}
            \PY{k}{return} \PY{n}{s\PYZus{}index\PYZus{}new}\PY{p}{,} \PY{n}{move}
        \PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}

    \PY{k}{return} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{k+kc}{None}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{globale-variablen-fuxfcr-die-anzeige}{%
\subsection{Globale Variablen fÃ¼r die
Anzeige}\label{globale-variablen-fuxfcr-die-anzeige}}

Nachdem alle Funktionen fÃ¼r die Bestimmung eines Zugs definiert worden
sind, gilt es die bereitgestellte UI der \texttt{python-chess}
Bibliothek zu erweitern. In Form von globalen Variablen werden
UI-Elemente definiert, die fÃ¼r die Eingabe eines neuen Zugs benÃ¶tigt
werden:

\begin{itemize}
\tightlist
\item
  \texttt{input\_field} = Ein Eingabefeld, in dem der nÃ¤chste Zug von
  WeiÃ eingetragen werden soll.
\item
  \texttt{execute\_button} = Ein Button, der nach der Auswahl des Zuges
  diesen auch auf dem Schachbrett ausfÃ¼hrt.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{input\PYZus{}field} \PY{o}{=} \PY{n}{widgets}\PY{o}{.}\PY{n}{Text}\PY{p}{(}\PY{p}{)}

\PY{n}{execute\PYZus{}button} \PY{o}{=} \PY{n}{widgets}\PY{o}{.}\PY{n}{Button}\PY{p}{(}
    \PY{n}{description}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Execute Move}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
    \PY{n}{disabled}\PY{o}{=}\PY{k+kc}{False}\PY{p}{,}
    \PY{n}{button\PYZus{}style}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
    \PY{n}{tooltip}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Executes the move selected with the dropdowns }\PY{l+s+s1}{\PYZdq{}}\PY{l+s+s1}{Piece:}\PY{l+s+s1}{\PYZdq{}}\PY{l+s+s1}{ and }\PY{l+s+s1}{\PYZdq{}}\PY{l+s+s1}{Move:}\PY{l+s+s1}{\PYZdq{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
    \PY{n}{icon}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{check}\PY{l+s+s1}{\PYZsq{}}
\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{globale-variablen-fuxfcr-den-aktuellen-spielzustand}{%
\subsection{Globale Variablen fÃ¼r den aktuellen
Spielzustand}\label{globale-variablen-fuxfcr-den-aktuellen-spielzustand}}

Damit der aktuelle Stand des Spiels auch ohne eine lineare Kette von
Funktionsaufrufen verfÃ¼gbar ist, werden diese Informationen in globalen
Variablen gespeichert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{S\PYZus{}N\PYZus{}TUPLES} \PY{o}{=} \PY{n}{load\PYZus{}s\PYZus{}n\PYZus{}sequence}\PY{p}{(}\PY{n}{FILE}\PY{p}{)}
\PY{n}{S\PYZus{}INDEX} \PY{o}{=} \PY{l+m+mi}{0}
\PY{n}{BOARD\PYZus{}INDEX} \PY{o}{=} \PY{l+m+mi}{0}
\end{Verbatim}
\end{tcolorbox}

    Weiterhin werden weitere globale Variablen definiert, die einerseits den
Dateinamen fÃ¼r die SpielzÃ¼ge (\texttt{filename}), andererseits das
Spielbrett zum Spielen gegen die KI innehalten (\texttt{board}).

    Innerhalb der python-chess library werden die Farben des Schachbretts
\texttt{chess.WHITE} und \texttt{chess.BLACK} als boolesche Variablen
definiert. Deswegen wurde zur spÃ¤teren Dokumentation, aber auch zum
Debuggen eine Funktion geschrieben, die die Farbe, die gerade am Zug
ist, als String zurÃ¼ckgibt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{get\PYZus{}color}\PY{p}{(}\PY{n}{turn}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{turn}\PY{p}{:}
        \PY{k}{return} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{White}\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{else}\PY{p}{:}
        \PY{k}{return} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Black}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}
\end{tcolorbox}

    Zum Definieren der globalen Variablen \texttt{filename} wird die
Funktion \texttt{update\_filename} definiert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{update\PYZus{}filename}\PY{p}{(}\PY{n}{new\PYZus{}value}\PY{p}{)}\PY{p}{:}
    \PY{k}{global} \PY{n}{FILENAME}
    \PY{n}{FILENAME} \PY{o}{=} \PY{n}{new\PYZus{}value}
\end{Verbatim}
\end{tcolorbox}

    Weiter werden fÃ¼r den Spielbeginn (\texttt{reset\_board}) und auch fÃ¼r
ausgefÃ¼hrte SpielzÃ¼ge (\texttt{reset\_input\_field}) Funktionen
geschrieben, die die UI Elemente auf ihren Standardwert zurÃ¼cksetzen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{reset\PYZus{}input\PYZus{}field}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{global} \PY{n}{input\PYZus{}field}
    \PY{n}{input\PYZus{}field}\PY{o}{.}\PY{n}{value} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{reset\PYZus{}board}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{global} \PY{n}{BOARD}
    \PY{n}{BOARD} \PY{o}{=} \PY{n}{create\PYZus{}board}\PY{p}{(}\PY{p}{)}
    \PY{k}{global} \PY{n}{S\PYZus{}INDEX}
    \PY{k}{global} \PY{n}{BOARD\PYZus{}INDEX}
    \PY{n}{tupel} \PY{o}{=} \PY{p}{(}\PY{n}{BOARD}\PY{o}{.}\PY{n}{turn}\PY{p}{,} \PY{n}{BOARD}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}
    \PY{n}{S\PYZus{}INDEX} \PY{o}{=} \PY{n}{find\PYZus{}situation\PYZus{}in\PYZus{}sequence}\PY{p}{(}\PY{n}{tupel}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}TUPLES}\PY{p}{)}
    \PY{k}{if} \PY{n}{BOARD}\PY{o}{.}\PY{n}{turn}\PY{p}{:}
        \PY{n}{S\PYZus{}INDEX}\PY{p}{,} \PY{n}{move} \PY{o}{=} \PY{n}{find\PYZus{}next\PYZus{}move}\PY{p}{(}\PY{n}{BOARD}\PY{p}{,} \PY{n}{S\PYZus{}INDEX}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}TUPLES}\PY{p}{)}
        \PY{k}{if} \PY{n}{S\PYZus{}INDEX} \PY{o}{==} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{No Move for white found}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{execute\PYZus{}move}\PY{p}{(}\PY{n}{move}\PY{p}{,} \PY{n}{BOARD}\PY{o}{.}\PY{n}{turn}\PY{p}{)}
            \PY{n}{reload\PYZus{}screen}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Zum DurchfÃ¼hren der SpielzÃ¼ge im Board-Objekt wird die Hilfsfunktion
\texttt{execute\_move} verwendet. Die Funktion erhÃ¤lt als Parameter
einen \texttt{chess.Move} und fÃ¼hrt diesen auf dem globalen
\texttt{BOARD} fÃ¼r die Farbe \texttt{chess.turn} durch. ZusÃ¤tzlich wird
in der Datei, die in unter dem Namen \texttt{filename} zu finden ist,
fÃ¼r den Zug ein Eintrag hinterlegt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{execute\PYZus{}move}\PY{p}{(}\PY{n}{move}\PY{p}{,} \PY{n}{turn}\PY{p}{)}\PY{p}{:}
    \PY{k}{global} \PY{n}{BOARD}
    \PY{k}{global} \PY{n}{S\PYZus{}INDEX}
    \PY{k}{global} \PY{n}{BOARD\PYZus{}INDEX}
    \PY{n}{move\PYZus{}file} \PY{o}{=} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Played\PYZus{}Games/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{FILENAME}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{a}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{k}{if} \PY{n}{turn}\PY{p}{:}
        \PY{n}{move\PYZus{}file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n+nb}{str}\PY{p}{(}\PY{n}{BOARD}\PY{o}{.}\PY{n}{fullmove\PYZus{}number}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{. }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{move}\PY{o}{.}\PY{n}{uci}\PY{p}{(}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ }\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{move\PYZus{}file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{move}\PY{o}{.}\PY{n}{uci}\PY{p}{(}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{move\PYZus{}file}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}
    \PY{n}{BOARD}\PY{o}{.}\PY{n}{push}\PY{p}{(}\PY{n}{move}\PY{p}{)}
    \PY{n}{tupel} \PY{o}{=} \PY{p}{(}\PY{n}{BOARD}\PY{o}{.}\PY{n}{turn}\PY{p}{,} \PY{n}{BOARD}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{p}{)}\PY{p}{)}
    \PY{n}{S\PYZus{}INDEX} \PY{o}{=} \PY{n}{find\PYZus{}situation\PYZus{}in\PYZus{}sequence}\PY{p}{(}\PY{n}{tupel}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}TUPLES}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{weitere-hilfsfunktionen}{%
\subsection{Weitere Hilfsfunktionen}\label{weitere-hilfsfunktionen}}

Das Ziel der Funktion \texttt{get\_pieces\_placed\_on\_board} besteht
darin, von einer mitgegebenen \texttt{chess.Color} die Figuren zu
bestimmen, die noch auf dem Schachbrett stehen. ZurÃ¼ck gibt sie ein
Dictionary, das als \texttt{key} die Schachfiguren und als
\texttt{value} eine Liste mit den Positionen der Figuren besitzt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{get\PYZus{}pieces\PYZus{}placed\PYZus{}on\PYZus{}board}\PY{p}{(}\PY{n}{color}\PY{p}{)}\PY{p}{:}
    \PY{n}{piece\PYZus{}type\PYZus{}to\PYZus{}string} \PY{o}{=} \PY{p}{\PYZob{}}
        \PY{l+m+mi}{1} \PY{p}{:} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Pawn}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
        \PY{l+m+mi}{2} \PY{p}{:} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Knight}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
        \PY{l+m+mi}{3} \PY{p}{:} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Bishop}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
        \PY{l+m+mi}{4} \PY{p}{:} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Rook}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
        \PY{l+m+mi}{5} \PY{p}{:} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Queen}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
        \PY{l+m+mi}{6} \PY{p}{:} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{King}\PY{l+s+s2}{\PYZdq{}}
    \PY{p}{\PYZcb{}}
    \PY{n}{pieces\PYZus{}with\PYZus{}position} \PY{o}{=} \PY{p}{\PYZob{}}
        \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Pawn}\PY{l+s+s2}{\PYZdq{}} \PY{p}{:} \PY{p}{[}\PY{p}{]}\PY{p}{,}
        \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Knight}\PY{l+s+s2}{\PYZdq{}} \PY{p}{:} \PY{p}{[}\PY{p}{]}\PY{p}{,}
        \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Bishop}\PY{l+s+s2}{\PYZdq{}} \PY{p}{:} \PY{p}{[}\PY{p}{]}\PY{p}{,}
        \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Rook}\PY{l+s+s2}{\PYZdq{}} \PY{p}{:} \PY{p}{[}\PY{p}{]}\PY{p}{,}
        \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Queen}\PY{l+s+s2}{\PYZdq{}} \PY{p}{:} \PY{p}{[}\PY{p}{]}\PY{p}{,}
        \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{King}\PY{l+s+s2}{\PYZdq{}} \PY{p}{:} \PY{p}{[}\PY{p}{]}
    \PY{p}{\PYZcb{}}
    \PY{k}{for} \PY{n}{piece\PYZus{}square}\PY{p}{,} \PY{n}{color\PYZus{}piece} \PY{o+ow}{in} \PY{n}{BOARD}\PY{o}{.}\PY{n}{piece\PYZus{}map}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n}{color\PYZus{}piece}\PY{o}{.}\PY{n}{color} \PY{o}{==} \PY{n}{color}\PY{p}{:}
            \PY{n}{pieces\PYZus{}with\PYZus{}position}\PY{p}{[}\PY{n}{piece\PYZus{}type\PYZus{}to\PYZus{}string}\PY{p}{[}\PY{n}{color\PYZus{}piece}\PY{o}{.}\PY{n}{piece\PYZus{}type}\PY{p}{]}\PY{p}{]}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{chess}\PY{o}{.}\PY{n}{square\PYZus{}name}\PY{p}{(}\PY{n}{piece\PYZus{}square}\PY{p}{)}\PY{p}{)}
    \PY{k}{return} \PY{n}{pieces\PYZus{}with\PYZus{}position}
\end{Verbatim}
\end{tcolorbox}

    Bei der Funktion \texttt{get\_moves\_from\_square} werden anhand der
mitgegebenen \texttt{legal\_moves} fÃ¼r ein vorgegebenes Feld die ZÃ¼ge
selektiert, die man von diesem Feld aus ziehen kann.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{get\PYZus{}moves\PYZus{}from\PYZus{}square}\PY{p}{(}\PY{n}{square}\PY{p}{,} \PY{n}{legal\PYZus{}moves}\PY{p}{)}\PY{p}{:}
    \PY{n}{moves} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{k}{for} \PY{n}{possible\PYZus{}move} \PY{o+ow}{in} \PY{n}{legal\PYZus{}moves}\PY{p}{:}
        \PY{k}{if} \PY{n}{square} \PY{o}{==} \PY{n}{chess}\PY{o}{.}\PY{n}{square\PYZus{}name}\PY{p}{(}\PY{n}{possible\PYZus{}move}\PY{o}{.}\PY{n}{from\PYZus{}square}\PY{p}{)}\PY{p}{:}
            \PY{n}{moves}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{possible\PYZus{}move}\PY{p}{)}
    \PY{k}{return} \PY{n}{moves}
\end{Verbatim}
\end{tcolorbox}

    Da die Anzeige des UI auf Konsolenausgaben basiert, muss diese auch nach
einem neuen Zug geleert werden, sodass die Konsole nicht mit den
Elementen Ã¼berflutet wird. HierfÃ¼r aktualisiert die Funktion
\texttt{reload\_screen} die Ausgabe und zeigt erneut das Schachbrett,
die beiden Dropdowns und den Knopf zum AusfÃ¼hren des Zugs an.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{reload\PYZus{}screen}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n}{clear\PYZus{}output}\PY{p}{(}\PY{p}{)}
    \PY{n}{display}\PY{p}{(}\PY{n}{BOARD}\PY{p}{,} \PY{n}{input\PYZus{}field}\PY{p}{,} \PY{n}{execute\PYZus{}button}\PY{p}{)}
    \PY{n}{display}\PY{p}{(}\PY{n}{Javascript}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{setTimeout(function focus() }\PY{l+s+s2}{\PYZob{}}\PY{l+s+s2}{document.querySelector(}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{input}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{).focus()\PYZcb{}, 100);}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{show\_end\_screen} hingegen zeigt nur das
Schachbrett an.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{show\PYZus{}end\PYZus{}screen}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n}{clear\PYZus{}output}\PY{p}{(}\PY{p}{)}
    \PY{n}{display}\PY{p}{(}\PY{n}{BOARD}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die \texttt{game\_result(result)} Funktion gibt den Grund, weshalb das
Spiel beendet wurde zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{game\PYZus{}result}\PY{p}{(}\PY{n}{result}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{result} \PY{o}{==} \PY{n}{Termination}\PY{o}{.}\PY{n}{CHECKMATE}\PY{p}{:}
        \PY{k}{return} \PY{n}{get\PYZus{}color}\PY{p}{(}\PY{n}{BOARD}\PY{o}{.}\PY{n}{turn}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ has lost because of Checkmate!}\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{elif} \PY{n}{result} \PY{o}{==} \PY{n}{Termination}\PY{o}{.}\PY{n}{STALEMATE}\PY{p}{:}
        \PY{k}{return} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{It}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{s a draw!}\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{elif} \PY{n}{result} \PY{o}{==} \PY{n}{Termination}\PY{o}{.}\PY{n}{INSUFFICIENT\PYZus{}MATERIAL}\PY{p}{:}
        \PY{k}{return} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{No side can win the game anymore!}\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{elif} \PY{n}{result} \PY{o}{==} \PY{n}{Termination}\PY{o}{.}\PY{n}{SEVENTYFIVE\PYZus{}MOVES}\PY{p}{:}
        \PY{k}{return} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The game is drawn because half\PYZhy{}move clock is greater than 150 since a capture or a pwn has been moved.}\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{elif} \PY{n}{result} \PY{o}{==} \PY{n}{Termination}\PY{o}{.}\PY{n}{FIVEFOLD\PYZus{}REPETITION}\PY{p}{:}
        \PY{k}{return} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The game is drawn because the current position occurred the fifth time!}\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{elif} \PY{n}{result} \PY{o}{==} \PY{n}{Termination}\PY{o}{.}\PY{n}{FIFTY\PYZus{}MOVES}\PY{p}{:}
        \PY{k}{return} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The game is drawn because half\PYZhy{}move clock is greater than 100 since a capture or a pwn has been moved.}\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{elif} \PY{n}{result} \PY{o}{==} \PY{n}{Termination}\PY{o}{.}\PY{n}{THREEFOLD\PYZus{}REPETITION}\PY{p}{:}
        \PY{k}{return} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The game is drawn because the current position occurred the third time!}\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{elif} \PY{n}{result} \PY{o}{==} \PY{n}{Termination}\PY{o}{.}\PY{n}{VARIANT\PYZus{}WIN}\PY{p}{:}
        \PY{k}{return} \PY{n}{get\PYZus{}color}\PY{p}{(}\PY{n}{BOARD}\PY{o}{.}\PY{n}{turn}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ has won because of variant\PYZhy{}specific conditions}\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{elif} \PY{n}{result} \PY{o}{==} \PY{n}{Termination}\PY{o}{.}\PY{n}{VARIANT\PYZus{}LOSS}\PY{p}{:}
        \PY{k}{return} \PY{n}{get\PYZus{}color}\PY{p}{(}\PY{n}{BOARD}\PY{o}{.}\PY{n}{turn}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ has lost because of variant\PYZhy{}specific conditions}\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{elif} \PY{n}{result} \PY{o}{==} \PY{n}{Termination}\PY{o}{.}\PY{n}{VARIANT\PYZus{}DRAW}\PY{p}{:}
        \PY{k}{return} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Game is drawn because of variant\PYZhy{}specific conditions!}\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{else}\PY{p}{:}
        \PY{k}{return} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Something went wrong!}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}
\end{tcolorbox}

    FÃ¼r den \texttt{execute\_button} und das \texttt{input\_field} wird eine
Funktion geschrieben, die fÃ¼r das AusfÃ¼hren des Zuges verantwortlich
ist. Diese wird entweder durch Klicken des Buttons oder DrÃ¼cken der
Enter-Taste aufgerufen. Sobald der eingegebene Zug ausgefÃ¼hrt wurde,
wird mithilfe der eingelesenen \(S_n\) Mengen der Zug fÃ¼r die KI
bestimmt. Weiterhin wird auch in dieser Funktion Ã¼berprÃ¼ft, ob das Spiel
bereits beendet wurde.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{execute\PYZus{}entered\PYZus{}move}\PY{p}{(}\PY{n}{change}\PY{p}{)}\PY{p}{:}
    \PY{k}{global} \PY{n}{BOARD}
    \PY{k}{global} \PY{n}{S\PYZus{}INDEX}
    \PY{k}{global} \PY{n}{BOARD\PYZus{}INDEX}
    \PY{k}{try}\PY{p}{:}
        \PY{k}{if} \PY{n}{input\PYZus{}field}\PY{o}{.}\PY{n}{value} \PY{o}{!=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
            \PY{n}{black\PYZus{}move} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Move}\PY{o}{.}\PY{n}{from\PYZus{}uci}\PY{p}{(}\PY{n}{input\PYZus{}field}\PY{o}{.}\PY{n}{value}\PY{p}{)}
            \PY{k}{if} \PY{n}{black\PYZus{}move} \PY{o+ow}{in} \PY{n+nb}{list}\PY{p}{(}\PY{n}{BOARD}\PY{o}{.}\PY{n}{legal\PYZus{}moves}\PY{p}{)}\PY{p}{:}
                \PY{n}{execute\PYZus{}move}\PY{p}{(}\PY{n}{black\PYZus{}move}\PY{p}{,} \PY{n}{BOARD}\PY{o}{.}\PY{n}{turn}\PY{p}{)}
                \PY{n}{reset\PYZus{}input\PYZus{}field}\PY{p}{(}\PY{p}{)}
                \PY{c+c1}{\PYZsh{} Next AI move executed by white}
                \PY{n}{S\PYZus{}INDEX}\PY{p}{,} \PY{n}{next\PYZus{}move} \PY{o}{=} \PY{n}{find\PYZus{}next\PYZus{}move}\PY{p}{(}\PY{n}{BOARD}\PY{p}{,} \PY{n}{S\PYZus{}INDEX}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}TUPLES}\PY{p}{)}
                \PY{k}{if} \PY{n}{S\PYZus{}INDEX} \PY{o}{==} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{:}
                    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{No Move for white found}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
                \PY{k}{else}\PY{p}{:}
                    \PY{n}{execute\PYZus{}move}\PY{p}{(}\PY{n}{next\PYZus{}move}\PY{p}{,} \PY{n}{BOARD}\PY{o}{.}\PY{n}{turn}\PY{p}{)}
                    \PY{n}{reload\PYZus{}screen}\PY{p}{(}\PY{p}{)}
                \PY{k}{if} \PY{n}{BOARD}\PY{o}{.}\PY{n}{legal\PYZus{}moves}\PY{o}{.}\PY{n}{count}\PY{p}{(}\PY{p}{)} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
                    \PY{c+c1}{\PYZsh{} If wanted add different endings}
                    \PY{n}{show\PYZus{}end\PYZus{}screen}\PY{p}{(}\PY{p}{)}
                    \PY{n}{result} \PY{o}{=} \PY{n}{BOARD}\PY{o}{.}\PY{n}{outcome}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{termination}
                    \PY{n+nb}{print}\PY{p}{(}\PY{n}{game\PYZus{}result}\PY{p}{(}\PY{n}{result}\PY{p}{)}\PY{p}{)}
            \PY{k}{else}\PY{p}{:}
                \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Entered a wrong move. Please try again!}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
                \PY{n+nb}{print}\PY{p}{(}\PY{n}{input\PYZus{}field}\PY{o}{.}\PY{n}{value}\PY{p}{)}
                \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
                \PY{n}{reload\PYZus{}screen}\PY{p}{(}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Enter a move!}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
            \PY{n}{reload\PYZus{}screen}\PY{p}{(}\PY{p}{)}
    \PY{k}{except} \PY{n+ne}{ValueError}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Entered a wrong move. Please try again!}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{input\PYZus{}field}\PY{o}{.}\PY{n}{value}\PY{p}{)}
        \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
        \PY{n}{reload\PYZus{}screen}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Damit die Funktion beim Klicken des \texttt{execute\_button} oder durch
DrÃ¼cken der Enter-Taste ausgefÃ¼hrt wird, muss diese den
\texttt{on\_click} Events zugewiesen werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{execute\PYZus{}button}\PY{o}{.}\PY{n}{on\PYZus{}click}\PY{p}{(}\PY{n}{execute\PYZus{}entered\PYZus{}move}\PY{p}{)}
\PY{n}{input\PYZus{}field}\PY{o}{.}\PY{n}{on\PYZus{}submit}\PY{p}{(}\PY{n}{execute\PYZus{}entered\PYZus{}move}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{start\_game} bereitet alle Parameter fÃ¼r einen
Spielverlauf vor. Dazu gehÃ¶rt: 
\begin{itemize}
	\item Erstellung eines neuen Boards. 
	\item Das Erstellen einer neuen Historie fÃ¼r das neu begonnene Spiel. 
	\item Anzeigen der neuen Spielsituation.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{start\PYZus{}game}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{global} \PY{n}{BOARD}
    \PY{n}{BOARD} \PY{o}{=} \PY{n}{create\PYZus{}board}\PY{p}{(}\PY{p}{)}
    \PY{n}{update\PYZus{}filename}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Move\PYZhy{}History\PYZus{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{datetime}\PY{o}{.}\PY{n}{today}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{n}{microsecond}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZus{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.txt}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{move\PYZus{}file} \PY{o}{=} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Played\PYZus{}Games/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{FILENAME}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{a}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{move\PYZus{}file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{BOARD}\PY{o}{.}\PY{n}{fen}\PY{p}{(}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{move\PYZus{}file}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}
    \PY{n}{reset\PYZus{}board}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Mit dem Aufruf der Funktion \texttt{start\_game} kann nun ein Spiel
gegen die KI gestartet werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{start\PYZus{}game}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{wiedergeben-einer-bereits-gespielten-partie}{%
\section{Wiedergeben einer bereits gespielten
Partie}\label{wiedergeben-einer-bereits-gespielten-partie}}

In diesem Bereich werden Funktionen definiert, die das Wiedergeben einer
Partie ermÃ¶glichen. HierfÃ¼r wird eine Spiel-Historie eingelesen.
Historien werden bei der AusfÃ¼hrung des
\texttt{03\_play\_against\_ai.ipynb} Notebooks erstellt und in dem
Ordner \texttt{Played\_Games} hinterlegt. Am Ende dieses Notebook wird
der Spielverlauf mit einem selbst festgelegten Tempo der ZÃ¼ge
dargestellt.

    \hypertarget{importieren-des-spielverlaufs}{%
\subsection{Importieren des
Spielverlaufs}\label{importieren-des-spielverlaufs}}

Als ersten Schritt muss eine beliebige Schach-Historie eingelesen
werden. HierfÃ¼r wird die Funktion \texttt{get\_lines\_from\_file}
definiert, die fÃ¼r einen mitgegebenen relativen Pfad zu einer
Schach-Historie (\texttt{file\_name}) die Zeilen der Datei ohne
Zeilenumbruch (\texttt{"\textbackslash{}n"}) zurÃ¼ckgibt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{get\PYZus{}lines\PYZus{}from\PYZus{}file}\PY{p}{(}\PY{n}{file\PYZus{}name}\PY{p}{)}\PY{p}{:}
    \PY{n}{move\PYZus{}file} \PY{o}{=} \PY{n+nb}{open}\PY{p}{(}\PY{n}{file\PYZus{}name}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{r}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{all\PYZus{}lines} \PY{o}{=} \PY{n}{move\PYZus{}file}\PY{o}{.}\PY{n}{readlines}\PY{p}{(}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} Remove \PYZsq{}\PYZbs{}n\PYZsq{} from the lines}
    \PY{n}{lines} \PY{o}{=} \PY{p}{[}\PY{n}{all\PYZus{}lines}\PY{p}{[}\PY{n}{x}\PY{p}{]}\PY{p}{[}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{all\PYZus{}lines}\PY{p}{)}\PY{p}{)} \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{all\PYZus{}lines}\PY{p}{[}\PY{n}{x}\PY{p}{]}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{12}\PY{p}{]}
    \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{all\PYZus{}lines}\PY{p}{)} \PY{o}{==} \PY{n+nb}{len}\PY{p}{(}\PY{n}{lines}\PY{p}{)} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{:}
        \PY{n}{lines} \PY{o}{+}\PY{o}{=} \PY{p}{[}\PY{n}{all\PYZus{}lines}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}
    \PY{k}{return} \PY{n}{lines}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{auslesen-der-startposition-und-zuxfcge}{%
\subsection{Auslesen der Startposition und
ZÃ¼ge}\label{auslesen-der-startposition-und-zuxfcge}}

Um den ausgewÃ¤hlten Spielverlauf darstellen zu kÃ¶nnen, muss ein neues
Spielbrett erstellt werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{BOARD} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Board}\PY{p}{(}\PY{p}{)}
\PY{n}{BOARD}
\end{Verbatim}
\end{tcolorbox}

    Mit der Funktion \texttt{set\_board} wird fÃ¼r einen relativen Pfad zu
einer Spielhistorie(\texttt{file\_name}) der Zustand in der globalen
Variable \texttt{BOARD} dargestellt, der zu Beginn der Datei
vorherrschte. Dieser kann in der ersten Zeile der Datei vorgefunden
werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{set\PYZus{}board}\PY{p}{(}\PY{n}{file\PYZus{}name}\PY{p}{)}\PY{p}{:}
    \PY{k}{global} \PY{n}{BOARD}
    \PY{n}{lines} \PY{o}{=} \PY{n}{get\PYZus{}lines\PYZus{}from\PYZus{}file}\PY{p}{(}\PY{n}{file\PYZus{}name}\PY{p}{)}
    \PY{n}{BOARD}\PY{o}{.}\PY{n}{set\PYZus{}fen}\PY{p}{(}\PY{n}{lines}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Um den Spielverlauf darstellen zu kÃ¶nnen, werden die SpielzÃ¼ge benÃ¶tigt.
Diese kÃ¶nnen mit der Funktion \texttt{get\_moves\_from\_file}
ausgewertet werden. HierfÃ¼r wird ebenfalls der relative Pfad zu einer
Spielhistorie (\texttt{file\_name}) mitgegeben.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{get\PYZus{}moves\PYZus{}from\PYZus{}file}\PY{p}{(}\PY{n}{file\PYZus{}name}\PY{p}{)}\PY{p}{:}
    \PY{n}{lines} \PY{o}{=} \PY{n}{get\PYZus{}lines\PYZus{}from\PYZus{}file}\PY{p}{(}\PY{n}{file\PYZus{}name}\PY{p}{)}
    \PY{n}{moves} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{k}{for} \PY{n}{line} \PY{o+ow}{in} \PY{n}{lines}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{]}\PY{p}{:}
        \PY{n}{split\PYZus{}move} \PY{o}{=} \PY{n}{line}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{moves}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{split\PYZus{}move}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{]}\PY{p}{)}
    \PY{k}{return} \PY{n}{moves}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{spiel-wiederholen}{%
\subsection{Spiel wiederholen}\label{spiel-wiederholen}}

Die Wiederholung des Spiels kann nun mit der AusfÃ¼hrung der Funktion
\texttt{start\_replay} begonnen werden. Diese benÃ¶tigt als Parameter den
relativen Pfad zu einer Spielhistorie (\texttt{file\_name}) und
zusÃ¤tzlich eine Anzahl an Sekunden, die nach der AusfÃ¼hrung eines Zuges
gewartet werden sollen (\texttt{delay}). Das Spiel wird daraufhin in der
Konsole fÃ¼r den Nutzer schrittweise angezeigt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{start\PYZus{}replay}\PY{p}{(}\PY{n}{file\PYZus{}name}\PY{p}{,} \PY{n}{delay}\PY{p}{)}\PY{p}{:}
    \PY{n}{set\PYZus{}board}\PY{p}{(}\PY{n}{file\PYZus{}name}\PY{p}{)}
    \PY{n}{moves} \PY{o}{=} \PY{n}{get\PYZus{}moves\PYZus{}from\PYZus{}file}\PY{p}{(}\PY{n}{file\PYZus{}name}\PY{p}{)} 
    \PY{n}{display}\PY{p}{(}\PY{n}{board}\PY{p}{)}
    \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
    \PY{k}{for} \PY{n}{move\PYZus{}pair} \PY{o+ow}{in} \PY{n}{moves}\PY{p}{:}
        \PY{k}{for} \PY{n}{move} \PY{o+ow}{in} \PY{n}{move\PYZus{}pair}\PY{p}{:}
            \PY{k}{if} \PY{n}{move} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
                \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Finished!}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{k}{else}\PY{p}{:}
                \PY{n}{clear\PYZus{}output}\PY{p}{(}\PY{p}{)}
                \PY{n}{board}\PY{o}{.}\PY{n}{push}\PY{p}{(}\PY{n}{chess}\PY{o}{.}\PY{n}{Move}\PY{o}{.}\PY{n}{from\PYZus{}uci}\PY{p}{(}\PY{n}{move}\PY{p}{)}\PY{p}{)}
                \PY{n}{display}\PY{p}{(}\PY{n}{board}\PY{p}{)}
                \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{n}{delay}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{start\PYZus{}replay}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Played\PYZus{}Games/Move\PYZhy{}History\PYZus{}2022\PYZhy{}03\PYZhy{}11 20\PYZus{}39\PYZus{}21.txt}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{auswerten-eines-schach-endspiels}{%
\section{Auswerten eines
Schach-Endspiels}\label{auswerten-eines-schach-endspiels}}

Neben der Berechnung der Endspiel-Situationen gilt es zu Ã¼berprÃ¼fen, ob
es sich bei den ZÃ¼gen der KI auch um optimale ZÃ¼ge handelt. HierfÃ¼r
werden im Rahmen von diesem Notebook Testszenarien geschrieben, welche
die Entscheidungen der KI bewerten. Zum Vergleich wurde die
Stockfish-Engine herangezogen. Stockfish ist die momentan (Stand: 2022)
beste Schach-Engine, die frei zur VerfÃ¼gung steht (Quelle:
\href{https://www.chess.com/terms/chess-engine}{chess.com} o. D.).

Insgesamt kÃ¶nnen vier unterschiedliche Szenarien in dem Notebook
getestet werden. Die Struktur der Tests ist wie folgt aufgebaut: 
\begin{itemize}
	\item \texttt{compare\_fen\_stockfish}: Dieser Test Ã¼berprÃ¼ft fÃ¼r eine
	mitgegebene FEN jeweils, wie viele ZÃ¼ge die Endspiel-Tabellen und
	Stockfish zum Gewinnen brauchen. 
	\item \texttt{test\_random\_boards}: Dieser
	Test Ã¼berprÃ¼ft fÃ¼r eine gegebene Anzahl \(n\) zufÃ¤lliger Situationen, ob
	Stockfish bessere Ergebnisse liefert. 
	\item \texttt{compare\_sequence\_stockfish}: Dieser Test Ã¼berprÃ¼ft fÃ¼r ein
	mitgegebenes \(n\) alle Situationen, die sich in der Menge \(S_n\)
	befinden, ob Stockfish oder die KI bessere Ergebnisse erzielt. 
	\item \texttt{compare\_all\_sequences}: Dieser Test Ã¼berprÃ¼ft fÃ¼r jegliche
	Situationen, die einer \(S_n\) Menge zugeordnet wurden, ob Stockfish
	eine LÃ¶sung in weniger ZÃ¼gen bestimmen kann.
\end{itemize}

Die Ergebnisse der letzten drei Tests werden im Ordner \texttt{/Tests}
gespeichert.

    \hypertarget{konfiguration}{%
\subsection{Konfiguration}\label{konfiguration}}

Zu Beginn mÃ¼ssen fÃ¼r den Vergleich unterschiedliche Variablen definiert
werden. Diese beinhalten den Namen der \texttt{.chessTest} Datei zu den
berechneten \(S_n\) Sequenzen und einen Pfad zur Stockfish-Installation.
Weiterhin wird eine globale Variable \texttt{VERBOSE} festgelegt, die
das Anzeigen von zusÃ¤tzlichen Ausgaben ein oder ausschaltet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{STOCKFISH\PYZus{}PATH} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{./stockfish/stockfish.exe}\PY{l+s+s2}{\PYZdq{}}
\PY{n}{VERBOSE} \PY{o}{=} \PY{k+kc}{False}

\PY{n}{STOCKFISH} \PY{o}{=} \PY{n}{stockfish}\PY{o}{.}\PY{n}{Stockfish}\PY{p}{(}\PY{n}{STOCKFISH\PYZus{}PATH}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{S\PYZus{}N\PYZus{}FILE} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}seq\PYZus{}queen}\PY{l+s+s2}{\PYZdq{}}

\PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen\PYZus{}short} \PY{o}{=} \PY{n}{load\PYZus{}s\PYZus{}n\PYZus{}fens}\PY{p}{(}\PY{n}{S\PYZus{}N\PYZus{}FILE}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{vergleich-zwischen-stockfish-und-ki}{%
\subsection{Vergleich zwischen Stockfish und
KI}\label{vergleich-zwischen-stockfish-und-ki}}

FÃ¼r den Vergleich einer Situation wird die Anzahl der ZÃ¼ge zwischen
Stockfish und der selbst geschriebenen KI miteinander verglichen. Eine
geringere Anzahl ist hierbei besser.

    \hypertarget{berechnung-der-zuglisten}{%
\subsubsection{Berechnung der
Zuglisten}\label{berechnung-der-zuglisten}}

Um die Anzahl der benÃ¶tigten ZÃ¼ge zu bestimmen, muss eine Liste angelegt
werden, welche ZÃ¼ge durchgefÃ¼hrt werden. DafÃ¼r muss immer ein optimaler
Zug bestimmt werden. Diese Aufgabe wird von der Funktion
\texttt{find\_next\_move} erfÃ¼llt. Diese berechnet fÃ¼r eine Ã¼bergebene
FEN (\texttt{fen}) den idealen Spielzug. FÃ¼r die Berechnung wird der
\texttt{s\_index} mitgegeben, in dem die FEN gefunden werden kann. Diese
wird fÃ¼r die Suche in den ``gekÃ¼rzten'' Ã¼bergebenen \(S_n\) Mengen
(\texttt{s\_n\_sequence\_short}) verwendet. Die Suche findet mithilfe
der bereits definierten Funktion \texttt{find\_situation\_in\_sequence}
statt.

Die ZÃ¼ge werden wie folgt bestimmt: 
\begin{itemize}
	\item \texttt{Stockfish}: FÃ¼r sowohl
	Schwarz als auch fÃ¼r WeiÃ, werden die ZÃ¼ge mit der Funktion
	\texttt{Stockfish().get\_best\_move()} bestimmt. 
	\item \texttt{KI}: FÃ¼r WeiÃ
	werden die ZÃ¼ge anhand der \(S_n\) Mengen bestimmt, die schwarzen ZÃ¼ge
	werden mit der Funktion \texttt{Stockfish().get\_best\_move()} gewÃ¤hlt.
\end{itemize}

Ein gegnerischer Spieler macht nicht immer einen im Sinne der KI
optimalen Zug, und das AuswÃ¤hlen zufÃ¤lliger ZÃ¼ge entsprÃ¤che einem
unerfahrenen Spieler. Um die Effizienz der KI gegen einen guten Spieler
zu demonstrieren werden die ZÃ¼ge von Schwarz beim Bestimmen der
Zuganzahl von Stockfish Ã¼bernommen. Aus demselben Grund spielt Stockfish
beim Bestimmen der Engine-Anzahl an ZÃ¼gen in der folgenden Funktion
\texttt{stockfish\_movelist} gegen sich selbst.

Die Funktion liefert als RÃ¼ckgabewert den besten Zug \texttt{move} und
der neue \texttt{s\_index}, welcher beschreibt, in welcher \(S_n\) Menge
die Spielsituation zu finden ist.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{find\PYZus{}next\PYZus{}move}\PY{p}{(}\PY{n}{fen}\PY{p}{,} \PY{n}{s\PYZus{}index}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}short}\PY{p}{)}\PY{p}{:}
    \PY{n}{STOCKFISH}\PY{o}{.}\PY{n}{set\PYZus{}fen\PYZus{}position}\PY{p}{(}\PY{n}{fen}\PY{p}{)}
    \PY{n}{curr\PYZus{}board} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Board}\PY{p}{(}\PY{n}{fen}\PY{p}{)}
    \PY{k}{if} \PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{:}
        \PY{k}{if} \PY{n}{VERBOSE}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZhy{}\PYZhy{}\PYZhy{}White:\PYZhy{}\PYZhy{}\PYZhy{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Starting in S}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{s\PYZus{}index}\PY{p}{)}\PY{p}{)}
        \PY{k}{for} \PY{n}{move} \PY{o+ow}{in} \PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n}{legal\PYZus{}moves}\PY{p}{:}
            \PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n}{push}\PY{p}{(}\PY{n}{move}\PY{p}{)}
            \PY{n}{cur\PYZus{}fen} \PY{o}{=} \PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n}{fen}\PY{p}{(}\PY{p}{)}
            \PY{n}{\PYZus{}tmp} \PY{o}{=} \PY{n}{find\PYZus{}situation\PYZus{}in\PYZus{}sequence}\PY{p}{(}\PY{n}{get\PYZus{}board\PYZus{}and\PYZus{}turn}\PY{p}{(}\PY{n}{cur\PYZus{}fen}\PY{p}{)}\PY{p}{,} \PY{p}{[}\PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}short}\PY{p}{[}\PY{n}{s\PYZus{}index} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{)}
            \PY{n}{s\PYZus{}index\PYZus{}tmp} \PY{o}{=} \PY{n}{s\PYZus{}index} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}
            \PY{k}{if} \PY{n}{\PYZus{}tmp} \PY{o}{!=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{:}
                \PY{k}{if} \PY{n}{VERBOSE}\PY{p}{:}
                    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{    Move: }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{move}\PY{p}{)}\PY{p}{)}
                    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{    S}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{s\PYZus{}index\PYZus{}tmp}\PY{p}{)}\PY{p}{)}
                    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Ended in S}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{s\PYZus{}index}\PY{p}{)}\PY{p}{)}
                \PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}
                \PY{k}{return} \PY{n}{s\PYZus{}index\PYZus{}tmp}\PY{p}{,} \PY{n}{move}
            \PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}

        \PY{k}{return} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{k+kc}{None}
    \PY{k}{else}\PY{p}{:}
        \PY{k}{if} \PY{n}{VERBOSE}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZhy{}\PYZhy{}\PYZhy{}Black:\PYZhy{}\PYZhy{}\PYZhy{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Starting in S}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{s\PYZus{}index}\PY{p}{)}\PY{p}{)}
        \PY{n}{move} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Move}\PY{o}{.}\PY{n}{from\PYZus{}uci}\PY{p}{(}\PY{n}{STOCKFISH}\PY{o}{.}\PY{n}{get\PYZus{}best\PYZus{}move}\PY{p}{(}\PY{p}{)}\PY{p}{)}
        \PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n}{push}\PY{p}{(}\PY{n}{move}\PY{p}{)}
        \PY{n}{cur\PYZus{}fen} \PY{o}{=} \PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n}{fen}\PY{p}{(}\PY{p}{)}
        \PY{n}{s\PYZus{}index} \PY{o}{=} \PY{n}{find\PYZus{}situation\PYZus{}in\PYZus{}sequence}\PY{p}{(}\PY{n}{get\PYZus{}board\PYZus{}and\PYZus{}turn}\PY{p}{(}\PY{n}{cur\PYZus{}fen}\PY{p}{)}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}short}\PY{p}{[}\PY{p}{:}\PY{n}{s\PYZus{}index}\PY{p}{]}\PY{p}{)}
        \PY{k}{if} \PY{n}{VERBOSE}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{    Move: }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{move}\PY{p}{)}\PY{p}{)}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{    S}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{s\PYZus{}index}\PY{p}{)}\PY{p}{)}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Ended in S}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{s\PYZus{}index}\PY{p}{)}\PY{p}{)}
        \PY{n}{curr\PYZus{}board}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}
        \PY{k}{return} \PY{n}{s\PYZus{}index}\PY{p}{,} \PY{n}{move}
\end{Verbatim}
\end{tcolorbox}

    Bei der Berechnung der ZÃ¼ge fÃ¼r die KI wird die Funktion
\texttt{calculate\_all\_moves} verwendet. Diese berechnet in einer
Schleife alle Moves ausgehend von einer FEN, bis die KI gewonnen hat.
Die Berechnung verwendet hierzu die FEN der Spielsituation
(\texttt{fen}) und die Liste der gekÃ¼rzten \(S_n\) Mengen
(\texttt{s\_n\_sequence\_short}). Mithilfe von diesen Parametern wird
eine Liste von ZÃ¼gen bestimmt, in der die Partie zwischen Stockfish und
der selbst geschriebenen KI beendet wurde.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{calculate\PYZus{}all\PYZus{}moves}\PY{p}{(}\PY{n}{fen}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}short}\PY{p}{)}\PY{p}{:}
    \PY{n}{moves} \PY{o}{=} \PY{p}{[}\PY{p}{]}

    \PY{n}{s\PYZus{}index} \PY{o}{=} \PY{n}{find\PYZus{}situation\PYZus{}in\PYZus{}sequence}\PY{p}{(}\PY{n}{get\PYZus{}board\PYZus{}and\PYZus{}turn}\PY{p}{(}\PY{n}{fen}\PY{p}{)}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}short}\PY{p}{)}

    \PY{n}{board} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Board}\PY{p}{(}\PY{n}{fen}\PY{p}{)}
    \PY{k}{while} \PY{n}{s\PYZus{}index} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{n}{cur\PYZus{}fen} \PY{o}{=} \PY{n}{board}\PY{o}{.}\PY{n}{fen}\PY{p}{(}\PY{p}{)}
        \PY{n}{s\PYZus{}index}\PY{p}{,} \PY{n}{next\PYZus{}move} \PY{o}{=} \PY{n}{find\PYZus{}next\PYZus{}move}\PY{p}{(}\PY{n}{cur\PYZus{}fen}\PY{p}{,} \PY{n}{s\PYZus{}index}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}short}\PY{p}{)}
        \PY{n}{board}\PY{o}{.}\PY{n}{push}\PY{p}{(}\PY{n}{next\PYZus{}move}\PY{p}{)}
        \PY{n}{moves}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{next\PYZus{}move}\PY{p}{)}

    \PY{k}{if} \PY{n}{s\PYZus{}index} \PY{o}{==} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{:}
        \PY{k}{return} \PY{k+kc}{None}

    \PY{k}{return} \PY{n}{moves}
\end{Verbatim}
\end{tcolorbox}

    Nachdem eine Liste aller ZÃ¼ge fÃ¼r die KI bestimmt wurden, gilt dies
gleichermaÃen fÃ¼r die Berechnung von Stockfish umzusetzen. HierfÃ¼r
erhÃ¤lt die Funktion \texttt{stockfish\_movelist} eine \texttt{fen} mit
der aktuellen Spielsituation. In der Funktion bestimmt Stockfish solange
die bestmÃ¶glichen ZÃ¼ge, bis die Partie beendet worden ist. Diese Liste
von ZÃ¼gen wird am Ende der Funktion zurÃ¼ckgegeben.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{stockfish\PYZus{}movelist}\PY{p}{(}\PY{n}{fen}\PY{p}{)}\PY{p}{:}
    \PY{n}{moves} \PY{o}{=} \PY{p}{[}\PY{p}{]}

    \PY{n}{board} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Board}\PY{p}{(}\PY{n}{fen}\PY{p}{)}

    \PY{k}{while} \PY{o+ow}{not} \PY{n}{board}\PY{o}{.}\PY{n}{is\PYZus{}game\PYZus{}over}\PY{p}{(}\PY{p}{)}\PY{p}{:}
        \PY{n}{STOCKFISH}\PY{o}{.}\PY{n}{set\PYZus{}fen\PYZus{}position}\PY{p}{(}\PY{n}{board}\PY{o}{.}\PY{n}{fen}\PY{p}{(}\PY{p}{)}\PY{p}{)}
        \PY{n}{next\PYZus{}move} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Move}\PY{o}{.}\PY{n}{from\PYZus{}uci}\PY{p}{(}\PY{n}{STOCKFISH}\PY{o}{.}\PY{n}{get\PYZus{}best\PYZus{}move}\PY{p}{(}\PY{p}{)}\PY{p}{)}
        \PY{n}{board}\PY{o}{.}\PY{n}{push}\PY{p}{(}\PY{n}{next\PYZus{}move}\PY{p}{)}
        \PY{n}{moves}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{next\PYZus{}move}\PY{p}{)}

    \PY{k}{return} \PY{n}{moves}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{hilfsfunktionen-fuxfcr-den-vergleich}{%
\subsubsection{Hilfsfunktionen fÃ¼r den
Vergleich}\label{hilfsfunktionen-fuxfcr-den-vergleich}}

Der Vergleich zwischen der Stockfish Engine und der KI basiert auf der
Anzahl der ZÃ¼ge, bis WeiÃ das Spiel gewonnen hat. HierfÃ¼r werden drei
Hilfsfunktionen definiert, die fÃ¼r den Vergleich benÃ¶tigt werden.

Bei der ersten Funktion handelt es sich um \texttt{compare\_move\_list}.
Diese erhÃ¤lt eine Liste von 3-Tupeln(\texttt{move\_count\_list}), die
als ersten Wert die Anzahl der ZÃ¼ge der KI beinhaltet und als zweiten
Wert die Anzahl der ZÃ¼ge, die Stockfish zum Beenden der Partie benÃ¶tigt
hat. Der dritte Wert stellt die Differenz zwischen den beiden Anzahlen
dar.

Als Ergebnis liefert die Funktion drei Werte zurÃ¼ck, die ein erstes
Abbild fÃ¼r die Performanz der KI darstellen. Der erste Wert ist die
Anzahl der Spielsituationen, bei denen Stockfish und die KI gleich viele
ZÃ¼ge benÃ¶tigt haben (\texttt{equal}). Der zweite Wert ist die Anzahl der
Spiele, bei denen die KI weniger ZÃ¼ge benÃ¶tigt hat (\texttt{ki\_better})
und der letzte Werte die Anzahl der Spiele, in der Stockish weniger ZÃ¼ge
benÃ¶tigt hat (\texttt{stockfish\_better}).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{compare\PYZus{}move\PYZus{}lists}\PY{p}{(}\PY{n}{move\PYZus{}count\PYZus{}list}\PY{p}{)}\PY{p}{:}
    \PY{n}{equal} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{n}{ki\PYZus{}better} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{n}{stockfish\PYZus{}better} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{k}{for} \PY{n}{ki\PYZus{}move}\PY{p}{,} \PY{n}{stock\PYZus{}move}\PY{p}{,} \PY{n}{diff} \PY{o+ow}{in} \PY{n}{move\PYZus{}count\PYZus{}list}\PY{p}{:}
        \PY{k}{if} \PY{n}{diff} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n}{equal} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
        \PY{k}{elif} \PY{n}{diff} \PY{o}{\PYZlt{}} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n}{ki\PYZus{}better} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{stockfish\PYZus{}better} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
    \PY{k}{return} \PY{n}{equal}\PY{p}{,} \PY{n}{ki\PYZus{}better}\PY{p}{,} \PY{n}{stockfish\PYZus{}better}
\end{Verbatim}
\end{tcolorbox}

    Diese Werte kÃ¶nnen nun weiter genutzt werden, indem neben der Anzahl der
Ergebnisse auch der Grad des Unterschieds bestimmt wird. HierfÃ¼r wurde
die Funktion \texttt{get\_average\_difference} definiert. Diese nutzt
ebenfalls die Liste von 3-Tupeln (\texttt{move\_count\_list}) als Input.
Die Funktion berechnet aus dieser Liste die durchschnittliche
Prozentzahl an ZÃ¼gen, welche von Stockfish oder der KI weniger benÃ¶tigt
werden. Diese werden fÃ¼r sowohl die KI(\texttt{avg\_ki\_better}), als
auch fÃ¼r Stockfish zurÃ¼ckgegeben(\texttt{avg\_stock\_better}).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{get\PYZus{}average\PYZus{}difference}\PY{p}{(}\PY{n}{move\PYZus{}count\PYZus{}list}\PY{p}{)}\PY{p}{:}
    \PY{n}{percentual\PYZus{}ki} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{percentual\PYZus{}stock} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{avg\PYZus{}ki\PYZus{}better} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{n}{avg\PYZus{}stock\PYZus{}better} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{k}{for} \PY{n}{ki\PYZus{}move}\PY{p}{,} \PY{n}{stock\PYZus{}move}\PY{p}{,} \PY{n}{diff} \PY{o+ow}{in} \PY{n}{move\PYZus{}count\PYZus{}list}\PY{p}{:}
        \PY{k}{if} \PY{n}{diff} \PY{o}{\PYZlt{}} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n}{percentual\PYZus{}ki}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n+nb}{round}\PY{p}{(}\PY{l+m+mi}{1} \PY{o}{\PYZhy{}} \PY{p}{(}\PY{n}{ki\PYZus{}move} \PY{o}{/} \PY{n}{stock\PYZus{}move}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)}\PY{p}{)}
        \PY{k}{elif} \PY{n}{diff} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n}{percentual\PYZus{}stock}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n+nb}{round}\PY{p}{(}\PY{l+m+mi}{1} \PY{o}{\PYZhy{}} \PY{p}{(}\PY{n}{stock\PYZus{}move} \PY{o}{/} \PY{n}{ki\PYZus{}move}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)}\PY{p}{)}
    \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{percentual\PYZus{}ki}\PY{p}{)} \PY{o}{!=} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{n}{avg\PYZus{}ki\PYZus{}better} \PY{o}{=} \PY{n+nb}{sum}\PY{p}{(}\PY{n}{percentual\PYZus{}ki}\PY{p}{)} \PY{o}{/} \PY{n+nb}{len}\PY{p}{(}\PY{n}{percentual\PYZus{}ki}\PY{p}{)}
    \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{percentual\PYZus{}stock}\PY{p}{)} \PY{o}{!=} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{n}{avg\PYZus{}stock\PYZus{}better} \PY{o}{=} \PY{n+nb}{sum}\PY{p}{(}\PY{n}{percentual\PYZus{}stock}\PY{p}{)} \PY{o}{/} \PY{n+nb}{len}\PY{p}{(}\PY{n}{percentual\PYZus{}stock}\PY{p}{)}
    \PY{k}{return} \PY{n}{avg\PYZus{}ki\PYZus{}better}\PY{p}{,} \PY{n}{avg\PYZus{}stock\PYZus{}better}
\end{Verbatim}
\end{tcolorbox}

    Die Ergebnisse des Vergleichs sollen abschlieÃend in einer Datei
gespeichert werden. Dies hat den Grund, dass bei einer groÃen Anzahl von
\(S_n\) Mengen die Auswertung nicht in einem unÃ¼bersichtlichen
Konsolenfenster durchgefÃ¼hrt werden muss und man die Ergebnisse mehrfach
betrachten kann. HierfÃ¼r wird die Funktion
\texttt{write\_result\_to\_file} definiert. Diese berechnet zunÃ¤chst mit
der \texttt{move\_count\_list} die Ergebnisse des Vergleichs. Hierzu
werden die zuvor definierten Funktionen \texttt{compare\_move\_lists}
und \texttt{get\_average\_difference} aufgerufen. AuÃerdem werden die
prozentualen Ergebnisse, welche Engine/KI das Problem besser gelÃ¶st hat,
innerhalb dieser Funktion berechnet. Die Ergebnisse werden letztendlich
in die Datei mit dem Namen \texttt{filename}.txt in den Ordner
\texttt{Tests} geschrieben. Zur Ãbersicht wird ein
\texttt{sequence\_index} mitgegeben werden, der eine Unterscheidung der
Tests ermÃ¶glicht.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{write\PYZus{}result\PYZus{}to\PYZus{}file}\PY{p}{(}\PY{n}{filename}\PY{p}{,} \PY{n}{sequence\PYZus{}index}\PY{p}{,} \PY{n}{move\PYZus{}count\PYZus{}list}\PY{p}{)}\PY{p}{:}
    \PY{n}{equal}\PY{p}{,} \PY{n}{ki\PYZus{}better}\PY{p}{,} \PY{n}{stockfish\PYZus{}better} \PY{o}{=} \PY{n}{compare\PYZus{}move\PYZus{}lists}\PY{p}{(}\PY{n}{move\PYZus{}count\PYZus{}list}\PY{p}{)}
    \PY{n}{avg\PYZus{}ki\PYZus{}better}\PY{p}{,} \PY{n}{avg\PYZus{}stock\PYZus{}better} \PY{o}{=} \PY{n}{get\PYZus{}average\PYZus{}difference}\PY{p}{(}\PY{n}{move\PYZus{}count\PYZus{}list}\PY{p}{)}
    \PY{n}{count} \PY{o}{=} \PY{n}{ki\PYZus{}better} \PY{o}{+} \PY{n}{stockfish\PYZus{}better} \PY{o}{+} \PY{n}{equal}
    \PY{n}{f} \PY{o}{=} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Tests/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{filename} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.txt}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{a+}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{sequence\PYZus{}index}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{:}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Stockfish war zu }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n+nb}{round}\PY{p}{(}\PY{p}{(}\PY{n}{stockfish\PYZus{}better} \PY{o}{/} \PY{n}{count}\PY{p}{)} \PY{o}{*} \PY{l+m+mi}{100}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZpc{}}\PY{l+s+s2}{ besser.}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Die KI war zu }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n+nb}{round}\PY{p}{(}\PY{p}{(}\PY{n}{ki\PYZus{}better} \PY{o}{/} \PY{n}{count}\PY{p}{)} \PY{o}{*} \PY{l+m+mi}{100}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZpc{}}\PY{l+s+s2}{ besser.}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Stockfish und die KI haben zu }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}
        \PY{n+nb}{round}\PY{p}{(}\PY{p}{(}\PY{n}{equal} \PY{o}{/} \PY{n}{count}\PY{p}{)} \PY{o}{*} \PY{l+m+mi}{100}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+si}{\PYZpc{} d}\PY{l+s+s2}{ie gleichen Ergebnisse erzielt.}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Sofern die KI besser war, hat sie durchschnittlich }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}
        \PY{n+nb}{round}\PY{p}{(}\PY{n}{avg\PYZus{}ki\PYZus{}better} \PY{o}{*} \PY{l+m+mi}{100}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZpc{}}\PY{l+s+s2}{ weniger ZÃ¼ge benÃ¶tigt.}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Sofern Stockfish besser war, hat sie durchschnittlich }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}
        \PY{n+nb}{round}\PY{p}{(}\PY{n}{avg\PYZus{}stock\PYZus{}better} \PY{o}{*} \PY{l+m+mi}{100}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZpc{}}\PY{l+s+s2}{ weniger ZÃ¼ge benÃ¶tigt.}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{implementierung-der-testszenarien}{%
\subsubsection{Implementierung der
Testszenarien}\label{implementierung-der-testszenarien}}

In diesem Abschnitt werden die zuvor definierten Testszenarien
implementiert. Diese erhalten eine Liste der \(S_n\) Mengen mit der
verkÃ¼rzten FEN Schreibweise (\texttt{s\_n\_sequence\_short}) oder die
Liste der \(S_n\) Mengen mit der vollstÃ¤ndigen FEN Schreibweise
(\texttt{s\_n\_sequence\_fen}). Diese werden fÃ¼r die Berechnungen der
ZÃ¼ge fÃ¼r die KI benÃ¶tigt und mÃ¼ssen deshalb in mindestens einer Form fÃ¼r
die Funktion vorliegen.

Das erste Testszenario sieht die ÃberprÃ¼fung eines Spielszenarios vor
(\texttt{fen}). Dies geschieht in der Funktion
\texttt{compare\_fen\_stockfish}. Das Ergebnis wird am Ende der Funktion
in der Konsole ausgegeben.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{compare\PYZus{}fen\PYZus{}stockfish}\PY{p}{(}\PY{n}{fen}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}short}\PY{p}{)}\PY{p}{:}
    \PY{n}{moves} \PY{o}{=} \PY{n}{calculate\PYZus{}all\PYZus{}moves}\PY{p}{(}\PY{n}{fen}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}short}\PY{p}{)}
    \PY{n}{stockfish\PYZus{}moves} \PY{o}{=} \PY{n}{stockfish\PYZus{}movelist}\PY{p}{(}\PY{n}{fen}\PY{p}{)}

    \PY{k}{if} \PY{n}{Moves} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{AI needed }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{moves}\PY{p}{)}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ moves to beat Stockfish as Black.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{AI found no way to beat Black.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Stockfish needed }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{stockfish\PYZus{}moves}\PY{p}{)}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ moves to win against itself.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Das zweite Szenario sieht vor, eine beliebige Anzahl (\texttt{count})
zufÃ¤lliger Boards zu vergleichen. Anhand der \texttt{count}-Variable
werden aus den \(S_n\) Mengen zufÃ¤llige Boards ausgewÃ¤hlt und der
Vergleich zwischen der KI und Stockfish durchgefÃ¼hrt. Das Ergebnis wird
mit \texttt{write\_result\_to\_file} in einer Datei hinterlegt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{random}


\PY{k}{def} \PY{n+nf}{test\PYZus{}random\PYZus{}boards}\PY{p}{(}\PY{n}{count}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}fen}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}short}\PY{p}{)}\PY{p}{:}
    \PY{n}{count\PYZus{}s\PYZus{}n} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}fen}\PY{p}{)}
    \PY{n}{move\PYZus{}count\PYZus{}list} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{k}{for} \PY{n}{board\PYZus{}c} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{count}\PY{p}{)}\PY{p}{:}
        \PY{n}{rand\PYZus{}sequence} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{count\PYZus{}s\PYZus{}n} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{)}
        \PY{n}{rand\PYZus{}board} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}fen}\PY{p}{[}\PY{n}{rand\PYZus{}sequence}\PY{p}{]}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{)}
        \PY{n}{rand\PYZus{}fen} \PY{o}{=} \PY{n+nb}{list}\PY{p}{(}\PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}fen}\PY{p}{[}\PY{n}{rand\PYZus{}sequence}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{n}{rand\PYZus{}board}\PY{p}{]}
        \PY{n}{ki\PYZus{}moves} \PY{o}{=} \PY{n}{calculate\PYZus{}all\PYZus{}moves}\PY{p}{(}\PY{n}{rand\PYZus{}fen}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}short}\PY{p}{)}
        \PY{n}{stockfish\PYZus{}moves} \PY{o}{=} \PY{n}{stockfish\PYZus{}movelist}\PY{p}{(}\PY{n}{rand\PYZus{}fen}\PY{p}{)}
        \PY{n}{move\PYZus{}count} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{ki\PYZus{}moves}\PY{p}{)}
        \PY{n}{cmp\PYZus{}move\PYZus{}count} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{stockfish\PYZus{}moves}\PY{p}{)}
        \PY{n}{move\PYZus{}count\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n+nb}{tuple}\PY{p}{(}\PY{p}{(}\PY{n}{move\PYZus{}count}\PY{p}{,} \PY{n}{cmp\PYZus{}move\PYZus{}count}\PY{p}{,} \PY{n}{move\PYZus{}count} \PY{o}{\PYZhy{}} \PY{n}{cmp\PYZus{}move\PYZus{}count}\PY{p}{)}\PY{p}{)}\PY{p}{)}
        \PY{n}{clear\PYZus{}output}\PY{p}{(}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Analyzed }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{board\PYZus{}c} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{count}\PY{p}{)}\PY{p}{)}

    \PY{n}{filename} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Random\PYZus{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{count}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZus{}Compare\PYZus{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{datetime}\PY{o}{.}\PY{n}{today}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{n}{microsecond}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
                                                                                                           \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZus{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.txt}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{write\PYZus{}result\PYZus{}to\PYZus{}file}\PY{p}{(}\PY{n}{filename}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{random}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{move\PYZus{}count\PYZus{}list}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    In diesem Beispiel werden 100 zufÃ¤llige Spielsituationen miteinander
verglichen:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{test\PYZus{}random\PYZus{}boards}\PY{p}{(}\PY{l+m+mi}{100}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen\PYZus{}short}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Bei \texttt{compare\_sequence\_stockfish} wird fÃ¼r jedes Board einer
\(S_n\) Menge Ã¼berprÃ¼ft, ob Stockfish oder die zuvor definierten Mengen
die Situation effizienter lÃ¶sen. In Form des \texttt{sequence\_index}
wird das \(n\) der \(S_n\) Menge Ã¼bergeben. ZusÃ¤tzlich kann ein Name fÃ¼r
eine Datei angegeben werden, sodass mehrere Testergebnisse in einer
Datei festgehalten werden kÃ¶nnen. Das Beschreiben der Datei erfolgt mit
der Funktion \texttt{write\_result\_to\_file}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{compare\PYZus{}sequence\PYZus{}stockfish}\PY{p}{(}\PY{n}{sequence\PYZus{}index}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}fen}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}short}\PY{p}{,} \PY{n}{g\PYZus{}filename}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)}\PY{p}{:}
    \PY{n}{s\PYZus{}n} \PY{o}{=} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}fen}\PY{p}{[}\PY{n}{sequence\PYZus{}index}\PY{p}{]}
    \PY{n}{move\PYZus{}count\PYZus{}list} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{n}{length} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{s\PYZus{}n}\PY{p}{)}
    \PY{n}{r} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{k}{for} \PY{n}{board\PYZus{}fen} \PY{o+ow}{in} \PY{n}{s\PYZus{}n}\PY{p}{:}
        \PY{n}{ai\PYZus{}moves} \PY{o}{=} \PY{n}{calculate\PYZus{}all\PYZus{}moves}\PY{p}{(}\PY{n}{board\PYZus{}fen}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}short}\PY{p}{)}
        \PY{n}{stockfish\PYZus{}moves} \PY{o}{=} \PY{n}{stockfish\PYZus{}movelist}\PY{p}{(}\PY{n}{board\PYZus{}fen}\PY{p}{)}
        \PY{n}{move\PYZus{}count} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{ai\PYZus{}moves}\PY{p}{)}
        \PY{n}{cmp\PYZus{}move\PYZus{}count} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{stockfish\PYZus{}moves}\PY{p}{)}
        \PY{n}{move\PYZus{}count\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n+nb}{tuple}\PY{p}{(}\PY{p}{(}\PY{n}{move\PYZus{}count}\PY{p}{,} \PY{n}{cmp\PYZus{}move\PYZus{}count}\PY{p}{,} \PY{n}{move\PYZus{}count} \PY{o}{\PYZhy{}} \PY{n}{cmp\PYZus{}move\PYZus{}count}\PY{p}{)}\PY{p}{)}\PY{p}{)}
        \PY{n}{clear\PYZus{}output}\PY{p}{(}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Comparing S\PYZus{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{sequence\PYZus{}index}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Compared }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{r} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{/}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{length}\PY{p}{)}\PY{p}{)}
        \PY{n}{r} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}

    \PY{k}{if} \PY{n}{g\PYZus{}filename} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
        \PY{n}{filename} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{sequence\PYZus{}index}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZus{}Compare\PYZus{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{datetime}\PY{o}{.}\PY{n}{today}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{n}{microsecond}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
                                                                                                                   \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZus{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.txt}\PY{l+s+s2}{\PYZdq{}}
        \PY{n}{write\PYZus{}result\PYZus{}to\PYZus{}file}\PY{p}{(}\PY{n}{filename}\PY{p}{,} \PY{n}{sequence\PYZus{}index}\PY{p}{,} \PY{n}{move\PYZus{}count\PYZus{}list}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{write\PYZus{}result\PYZus{}to\PYZus{}file}\PY{p}{(}\PY{n}{g\PYZus{}filename}\PY{p}{,} \PY{n}{sequence\PYZus{}index}\PY{p}{,} \PY{n}{move\PYZus{}count\PYZus{}list}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Als Beispiel wird hier der Vergleich zwischen der KI und Stockfish fÃ¼r
die Menge \(S_{20}\) vorgenommen:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{compare\PYZus{}sequence\PYZus{}stockfish}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen\PYZus{}short}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Das letzte Testszenario sieht vor, alle zuvor bestimmten Boards mit dem
LÃ¶sungsweg von Stockfish zu vergleichen. HierfÃ¼r geht die Funktion
\texttt{compare\_all\_sequences} alle \(S_n\) Mengen durch und
vergleicht diese jeweils mit der LÃ¶sung von Stockfish. Alle Ergebnisse
werden in eine Datei geschrieben.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{compare\PYZus{}all\PYZus{}sequences}\PY{p}{(}\PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}fen}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}short}\PY{p}{)}\PY{p}{:}
    \PY{n}{filename} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{All\PYZus{}S\PYZus{}Compare\PYZus{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{datetime}\PY{o}{.}\PY{n}{today}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{n}{microsecond}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZus{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.txt}\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}fen}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Comparing S\PYZus{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{i}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{...}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n}{compare\PYZus{}sequence\PYZus{}stockfish}\PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}fen}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence\PYZus{}short}\PY{p}{,} \PY{n}{filename}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{compare\PYZus{}all\PYZus{}sequences}\PY{p}{(}\PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen\PYZus{}short}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    FÃ¼r die visuelle Darstellung der ZÃ¼ge wird die Funktion
\texttt{show\_movelist} definiert. Diese zeigt auf einem
\texttt{chess.Board} Objekt eine mitgegebene Liste von ZÃ¼gen
zeitverzÃ¶gert an. FÃ¼r die Darstellung erhÃ¤lt die Funktion die
\texttt{fen}, die die Spielsituation zu Beginn der Partie darstellt.
Weiter muss eine Liste von SpielzÃ¼gen (\texttt{moves}), die dargestellt
werden sollen, der Funktion mitgegeben werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{show\PYZus{}movelist}\PY{p}{(}\PY{n}{fen}\PY{p}{,} \PY{n}{moves}\PY{p}{)}\PY{p}{:}
    \PY{n}{presentation\PYZus{}board} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Board}\PY{p}{(}\PY{n}{fen}\PY{p}{)}
    \PY{n}{display}\PY{p}{(}\PY{n}{presentation\PYZus{}board}\PY{p}{)}
    \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
    \PY{k}{for} \PY{n}{move} \PY{o+ow}{in} \PY{n}{moves}\PY{p}{:}
        \PY{n}{presentation\PYZus{}board}\PY{o}{.}\PY{n}{push}\PY{p}{(}\PY{n}{move}\PY{p}{)}
        \PY{n}{clear\PYZus{}output}\PY{p}{(}\PY{n}{wait}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
        \PY{n}{display}\PY{p}{(}\PY{n}{presentation\PYZus{}board}\PY{p}{)}
        \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{uxfcberpruxfcfen-der-s_n-mengen}{%
\section{\texorpdfstring{ÃberprÃ¼fen der \(S_n\)
Mengen}{ÃberprÃ¼fen der S\_n Mengen}}\label{uxfcberpruxfcfen-der-s_n-mengen}}

Bei der Bestimmung der \(S_n\) Mengen wurden alle mÃ¶glichen ZÃ¼ge
rÃ¼ckwÃ¤rts durchgefÃ¼hrt. Damit die Retrograde Analyse erfolgreich zum
Gewinnen von Endspielsituationen angewandt werden kann, muss diese
Berechnung erfolgreich gewesen sein. Um sicherzustellen, dass die
Situationen, die z. B. in \(S_{10}\) zu finden sind, auch wirklich in
\( \leq 10\) ZÃ¼gen beendet werden, wurden in diesem Notebook Funktionen
definiert, die diesen Aspekt Ã¼berprÃ¼fen. HierfÃ¼r werden zuerst die
berechneten \(S_n\) Mengen aus der Datei geladen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen\PYZus{}short} \PY{o}{=} \PY{n}{load\PYZus{}s\PYZus{}n\PYZus{}fens}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S\PYZus{}n\PYZus{}seq\PYZus{}rook}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die erste Funktion zur ÃberprÃ¼fung, ist
\texttt{fen\_in\_lower\_sequence}. Diese Ã¼berprÃ¼ft fÃ¼r eine mitgegebene
\texttt{fen}, ob diese in einer \(S_n\) Menge liegt, fÃ¼r die gilt: \[
n < sequence\_index
\]

Die Funktion gibt hierfÃ¼r einen booleschen Wert zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{fen\PYZus{}in\PYZus{}lower\PYZus{}sequence}\PY{p}{(}\PY{n}{fen}\PY{p}{,} \PY{n}{sequence\PYZus{}index}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}short}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{s} \PY{o+ow}{in} \PY{n}{s\PYZus{}n\PYZus{}short}\PY{p}{[}\PY{p}{:}\PY{n}{sequence\PYZus{}index}\PY{p}{]}\PY{p}{:}
        \PY{k}{if} \PY{n}{fen} \PY{o+ow}{in} \PY{n}{s}\PY{p}{:}
            \PY{k}{return} \PY{k+kc}{True}
    \PY{k}{return} \PY{k+kc}{False}
\end{Verbatim}
\end{tcolorbox}

    Eine weitere ÃberprÃ¼fung liegt darin, dass keine der Schachbretter in
eine zu niedrige \(S_n\) Menge eingeordnet wurde. Dies wird mit der
Funktion \texttt{every\_move\_of\_sequence\_in\_lower} umgesetzt.
HierfÃ¼r erhÃ¤lt sie eine \texttt{sequence\_index}, die Ã¼berprÃ¼ft werden
soll. FÃ¼r jede Spielsituation wird Folgendes Ã¼berprÃ¼ft:

\[
\forall board \in S_n : move \in board.legal\_moves \implies board.push(move) \in S_m \land m<n
\]

Als Ergebnis gibt die Funktion eine boolesche Variable zurÃ¼ck, die
\texttt{True} zurÃ¼ckgibt, falls die Bedingung erfÃ¼llt ist, ansonsten
\texttt{False}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{every\PYZus{}move\PYZus{}of\PYZus{}sequence\PYZus{}in\PYZus{}lower}\PY{p}{(}\PY{n}{sequence\PYZus{}index}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}fen}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}short}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Checking S\PYZus{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{sequence\PYZus{}index}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{...}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{sequence\PYZus{}fen} \PY{o}{=} \PY{n}{s\PYZus{}n\PYZus{}fen}\PY{p}{[}\PY{n}{sequence\PYZus{}index}\PY{p}{]}
    \PY{k}{for} \PY{n}{fen} \PY{o+ow}{in} \PY{n}{sequence\PYZus{}fen}\PY{p}{:}
        \PY{n}{cur\PYZus{}board} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Board}\PY{p}{(}\PY{n}{fen}\PY{p}{)}
        \PY{k}{if} \PY{o+ow}{not} \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{:}
            \PY{k}{for} \PY{n}{move} \PY{o+ow}{in} \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{legal\PYZus{}moves}\PY{p}{:}
                \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{push}\PY{p}{(}\PY{n}{move}\PY{p}{)}
                \PY{n}{cur\PYZus{}short} \PY{o}{=} \PY{n}{get\PYZus{}board\PYZus{}and\PYZus{}turn}\PY{p}{(}\PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{fen}\PY{p}{(}\PY{p}{)}\PY{p}{)}
                \PY{k}{if} \PY{o+ow}{not} \PY{n}{fen\PYZus{}in\PYZus{}lower\PYZus{}sequence}\PY{p}{(}\PY{n}{cur\PYZus{}short}\PY{p}{,} \PY{n}{sequence\PYZus{}index}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}short}\PY{p}{)}\PY{p}{:}
                    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Fen: }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{cur\PYZus{}short} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ not in lower S}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
                    \PY{k}{return} \PY{k+kc}{False}
                \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}
            \PY{k}{return} \PY{k+kc}{True}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{in\PYZus{}lower} \PY{o}{=} \PY{k+kc}{False}
            \PY{k}{for} \PY{n}{move} \PY{o+ow}{in} \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{legal\PYZus{}moves}\PY{p}{:}
                \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{push}\PY{p}{(}\PY{n}{move}\PY{p}{)}
                \PY{n}{cur\PYZus{}short} \PY{o}{=} \PY{n}{get\PYZus{}board\PYZus{}and\PYZus{}turn}\PY{p}{(}\PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{fen}\PY{p}{(}\PY{p}{)}\PY{p}{)}
                \PY{k}{if} \PY{n}{fen\PYZus{}in\PYZus{}lower\PYZus{}sequence}\PY{p}{(}\PY{n}{cur\PYZus{}short}\PY{p}{,} \PY{n}{sequence\PYZus{}index}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}short}\PY{p}{)}\PY{p}{:}
                    \PY{n}{in\PYZus{}lower} \PY{o}{=} \PY{k+kc}{True}
                \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}
            \PY{k}{return} \PY{n}{in\PYZus{}lower}
\end{Verbatim}
\end{tcolorbox}

    Die folgende Zelle fÃ¼hrt diesen Test durch.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{n}{every\PYZus{}move\PYZus{}of\PYZus{}sequence\PYZus{}in\PYZus{}lower}\PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen\PYZus{}short}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{find\_move\_count} kann fÃ¼r folgende ÃberprÃ¼fung
verwendet werden:

\[
 \forall board \in S_n \implies max(find\_move\_count(board)) = n \]

Hierbei berechnet \texttt{find\_move\_count} jeden Ablauf einer
Schach-Partie, bis ein Schachmatt erzielt worden ist. Da aber die
Spielsituation in die Menge \(S_n\) zugeordnet wurde, muss auf jeden
Fall eine dieser Zahlen den Wert n betragen, da ansonsten das
Schachbrett der falschen \(S_n\) Menge zugeordnet wurde.

Die Implementierung der Funktion \texttt{find\_move\_count} erfolgt
rekursiv. Die Funktion ruft sich selbst auf, bis ein Schachmatt erzielt
worden ist. FÃ¼r einen derartigen Aufruf wird die
\texttt{sequence\_index}, in der sich die \texttt{fen} befindet,
mitgegeben. AuÃerdem muss das \texttt{move\_set}, dass auch als
RÃ¼ckgabewert fungiert, mitgegeben werden, da darin die Anzahl der ZÃ¼ge
gespeichert werden, die zum LÃ¶sen jeglicher SpielablÃ¤ufe benÃ¶tigt
werden. Der Parameter \texttt{move\_count} resultiert ebenfalls durch
die Rekursion, da in ihr die aktuelle Anzahl an ausgefÃ¼hrten SpielzÃ¼gen
gespeichert wird. Aufgrund des Aufrufs der Funktion
\texttt{find\_situation\_in\_sequence} wird zusÃ¤tzlich noch die Liste
der gekÃ¼rzten \(S_n\) Mengen beigefÃ¼gt (\texttt{s\_n\_short}). Die
Funktion gibt letztendlich eine Menge an SpielzÃ¼gen zurÃ¼ck, die fÃ¼r die
unterschiedlichen AblÃ¤ufe der Spielsituation benÃ¶tigt wurden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{find\PYZus{}move\PYZus{}count}\PY{p}{(}\PY{n}{sequence\PYZus{}index}\PY{p}{,} \PY{n}{fen}\PY{p}{,} \PY{n}{move\PYZus{}count}\PY{p}{,} \PY{n}{move\PYZus{}set}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}short}\PY{p}{)}\PY{p}{:}
    \PY{n}{cur\PYZus{}board} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Board}\PY{p}{(}\PY{n}{fen}\PY{p}{)}
    \PY{n}{moves} \PY{o}{=} \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{legal\PYZus{}moves}
    \PY{k}{if} \PY{n}{moves}\PY{o}{.}\PY{n}{count}\PY{p}{(}\PY{p}{)} \PY{o}{==} \PY{l+m+mi}{0} \PY{o+ow}{and} \PY{n}{sequence\PYZus{}index} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{n}{move\PYZus{}set}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{move\PYZus{}count}\PY{p}{)}
        \PY{k}{return} \PY{n}{move\PYZus{}set}
    \PY{k}{if} \PY{o+ow}{not} \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{turn}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} print(\PYZdq{}Black:\PYZdq{})}
        \PY{k}{for} \PY{n}{move} \PY{o+ow}{in} \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{legal\PYZus{}moves}\PY{p}{:}
            \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{push}\PY{p}{(}\PY{n}{move}\PY{p}{)}
            \PY{n}{move\PYZus{}count} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
            \PY{n}{cur\PYZus{}fen} \PY{o}{=} \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{fen}\PY{p}{(}\PY{p}{)}
            \PY{n}{new\PYZus{}seq} \PY{o}{=} \PY{n}{find\PYZus{}situation\PYZus{}in\PYZus{}sequence}\PY{p}{(}\PY{n}{cur\PYZus{}fen}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}short}\PY{p}{)}
            \PY{c+c1}{\PYZsh{} print(new\PYZus{}seq, \PYZdq{};\PYZdq{} , cur\PYZus{}fen)}
            \PY{n}{move\PYZus{}set} \PY{o}{=} \PY{n}{find\PYZus{}move\PYZus{}count}\PY{p}{(}\PY{n}{new\PYZus{}seq}\PY{p}{,} \PY{n}{cur\PYZus{}fen}\PY{p}{,} \PY{n}{move\PYZus{}count}\PY{p}{,} \PY{n}{move\PYZus{}set}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}short}\PY{p}{)}
            \PY{n}{move\PYZus{}count} \PY{o}{\PYZhy{}}\PY{o}{=} \PY{l+m+mi}{1}
            \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}
    \PY{k}{else}\PY{p}{:} 
        \PY{c+c1}{\PYZsh{} print(\PYZdq{}White:\PYZdq{})}
        \PY{k}{for} \PY{n}{move} \PY{o+ow}{in} \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{legal\PYZus{}moves}\PY{p}{:}
            \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{push}\PY{p}{(}\PY{n}{move}\PY{p}{)}
            \PY{n}{cur\PYZus{}fen} \PY{o}{=} \PY{n}{get\PYZus{}board\PYZus{}and\PYZus{}turn}\PY{p}{(}\PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{fen}\PY{p}{(}\PY{p}{)}\PY{p}{)}
            \PY{k}{if} \PY{n}{fen\PYZus{}in\PYZus{}lower\PYZus{}sequence}\PY{p}{(}\PY{n}{cur\PYZus{}fen}\PY{p}{,} \PY{n}{sequence\PYZus{}index}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}short}\PY{p}{)}\PY{p}{:}
                \PY{n}{new\PYZus{}seq} \PY{o}{=} \PY{n}{find\PYZus{}situation\PYZus{}in\PYZus{}sequence}\PY{p}{(}\PY{n}{cur\PYZus{}fen}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}short}\PY{p}{)}
                \PY{n}{move\PYZus{}count} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
                \PY{n}{move\PYZus{}set} \PY{o}{=} \PY{n}{find\PYZus{}move\PYZus{}count}\PY{p}{(}\PY{n}{new\PYZus{}seq}\PY{p}{,} \PY{n}{cur\PYZus{}fen}\PY{p}{,} \PY{n}{move\PYZus{}count}\PY{p}{,} \PY{n}{move\PYZus{}set}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}short}\PY{p}{)}
                \PY{n}{move\PYZus{}count} \PY{o}{\PYZhy{}}\PY{o}{=} \PY{l+m+mi}{1}
            \PY{n}{cur\PYZus{}board}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}
    \PY{k}{return} \PY{n}{move\PYZus{}set}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{find\PYZus{}move\PYZus{}count}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{8/8/8/3K4/8/5R2/2k5/8 b \PYZhy{} \PYZhy{} 0 1}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen\PYZus{}short}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Zur ÃberprÃ¼fung, dass nun Board der falschen \(S_n\) Menge zugeordnet
wurde, wird die Funktion \texttt{check\_boards\_in\_correct\_sequence}
definiert. Diese Ã¼berprÃ¼ft fÃ¼r einen \texttt{sequence\_index} in einer
mitgegebenen Liste von \(S_n\) Mengen (\texttt{s\_n\_fen}), ob die
Spielsituationen der Menge an dem Index \texttt{sequence\_index} auch
maximal \(n\) ZÃ¼ge bis zum Ende der Partie benÃ¶tigen. Dies gelingt mit
der Funktion \texttt{find\_move\_count}, die zusÃ¤tzlich noch die
gekÃ¼rzte Schreibweise der \(S_n\) Mengen benÃ¶tigt
(\texttt{s\_n\_short}). Die Funktion gibt in Form einer Konsolenausgabe
an, welche der FENs in eine falsche \(S_n\) Menge zugeordnet worden
sind.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{check\PYZus{}boards\PYZus{}in\PYZus{}correct\PYZus{}sequence}\PY{p}{(}\PY{n}{sequence\PYZus{}index}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}fen}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}short}\PY{p}{)}\PY{p}{:}
    \PY{n}{invalid} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Comparing S\PYZus{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{sequence\PYZus{}index}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{...}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{k}{for} \PY{n}{fen} \PY{o+ow}{in} \PY{n}{s\PYZus{}n\PYZus{}fen}\PY{p}{[}\PY{n}{sequence\PYZus{}index}\PY{p}{]}\PY{p}{:}
        \PY{n}{move\PYZus{}set} \PY{o}{=} \PY{n}{find\PYZus{}move\PYZus{}count}\PY{p}{(}\PY{n}{sequence\PYZus{}index}\PY{p}{,} \PY{n}{fen}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}short}\PY{p}{)}
        \PY{k}{if} \PY{n+nb}{max}\PY{p}{(}\PY{n}{move\PYZus{}set}\PY{p}{)} \PY{o}{!=} \PY{n}{sequence\PYZus{}index}\PY{p}{:}
            \PY{n}{invalid} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{fen}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Invalid boards: }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{invalid}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{check\PYZus{}boards\PYZus{}in\PYZus{}correct\PYZus{}sequence}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen\PYZus{}short}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    ZusÃ¤tzlich zum rechnerischen ÃberprÃ¼fen der Ergebnisse kann eine andere
Methode zum Verifizieren verwendet werden. Schach-Endspieldatenbanken
sind keine neue Erfindung und wurden bereits von anderen Forschern
entwickelt. Ein lang anhaltendes Projekt, welches gegenwÃ¤rtig
Datenbanken fÃ¼r Situationen mit bis zu 7 Figuren auf dem Spielfeld
anbietet ist \href{https://syzygy-tables.info/}{Syzygy}. Das Projekt
hÃ¤lt zwei Datentypen fÃ¼r alle Spielsituationen vor: WDL Daten und DTZ
Daten.

WDL steht fÃ¼r Win / Draw / Loss und gibt dem Nutzer eine Information
Ã¼ber den Wert einer Spielsituation. Eine Anfrage an die Datenbank mit
einer Situation wird mit einem der folgenden Werte beantwortet: -2, -1,
0, 1, 2. Positive Werte implizieren, dass bei perfektem Spiel der
aktuelle Spieler gewinnt, negative Werte bedeuten, dass der aktuelle
Spieler verliert. Die 0 bedeutet, dass das Spiel (wenn beide Seiten
perfekt spielen) in einem Unentschieden endet. Eine Zwei ist ein
sicherer Sieg / Verlust, wÃ¤hrend eine Eins in einem Gewinn oder
unentschieden mittels der 50-Zug Regel enden kann.

Die Interessantere der Dateien ist die DTZ-Datei. DTZ steht fÃ¼r Distance
to Zero. Die DTZ Tabelle enthÃ¤lt Werte von -100 bis 100. Positiv,
Negativ und Null kann genau wie WDL interpretiert werden. Die Zahlen von
-100 bis -1 und 1 bis 100 geben die Anzahl der HalbzÃ¼ge bis zu einem
Gewinn (oder Reset der 50-ZÃ¼ge Regel) an. Stetiges verringern einer
positiven DTZ fÃ¼hrt also zu einem Gewinn.

Die DTZ-Zahl einer Spielsituation kann mit dem \(n\) verglichen werden,
in welcher Menge \(S_n\) diese Situation in der \texttt{.chessAI}
eingeordnet wurde. Stimmen diese Zahlen Ã¼berein, war die Berechnung
korrekt.

\emph{Hinweis: Je nach AusfÃ¼hrung der Syzygy-Tabellen werden halbe oder
ganze ZÃ¼ge gespeichert, es muss daher beim Vergleich eine Toleranz von
einem \(n\) akzeptiert werden.}

Die Funktion \texttt{compare\_with\_syzygy()} fÃ¼hrt diesen Vergleich
durch und gibt die Anzahl falsch eingeordneter Situationen zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{compare\PYZus{}with\PYZus{}syzygy}\PY{p}{(}\PY{n}{syzygy}\PY{p}{,} \PY{n}{s\PYZus{}n\PYZus{}sequence}\PY{p}{)}\PY{p}{:}
    \PY{n}{counter} \PY{o}{=} \PY{l+m+mi}{0}
    
    \PY{k}{for} \PY{n}{n} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{s\PYZus{}n\PYZus{}sequence}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{n}{count} \PY{o}{=} \PY{l+m+mi}{0}
        \PY{k}{for} \PY{n}{fen} \PY{o+ow}{in} \PY{n}{s\PYZus{}n\PYZus{}sequence}\PY{p}{[}\PY{n}{n}\PY{p}{]}\PY{p}{:}
            \PY{n}{chess\PYZus{}board} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{Board}\PY{p}{(}\PY{n}{fen}\PY{p}{)}
            \PY{k}{if} \PY{n}{n} \PY{o}{!=} \PY{n+nb}{abs}\PY{p}{(}\PY{n}{syzygy}\PY{o}{.}\PY{n}{probe\PYZus{}dtz}\PY{p}{(}\PY{n}{chess\PYZus{}board}\PY{p}{)}\PY{p}{)} \PY{o}{!=} \PY{n}{n} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{:}
                \PY{n}{count} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{S}\PY{l+s+si}{\PYZob{}}\PY{n}{n}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{: Syzygy believes }\PY{l+s+si}{\PYZob{}}\PY{n}{count}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ of }\PY{l+s+si}{\PYZob{}}\PY{n+nb}{len}\PY{p}{(}\PY{n}{s\PYZus{}n\PYZus{}sequence}\PY{p}{[}\PY{n}{n}\PY{p}{]}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ Situations are wrongly placed in the sequence.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Syzygy believes }\PY{l+s+si}{\PYZob{}}\PY{n}{counter}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ Situations are wrongly placed in the sequence.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{k}{return} \PY{n}{count}
\end{Verbatim}
\end{tcolorbox}

    Die Syzygy-Dateien mÃ¼ssen sich entweder im Ordner \texttt{./syzygy}
befinden oder der Pfad angepasst werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{SYZYGY} \PY{o}{=} \PY{n}{chess}\PY{o}{.}\PY{n}{syzygy}\PY{o}{.}\PY{n}{Tablebase}\PY{p}{(}\PY{p}{)}
\PY{n}{SYZYGY}\PY{o}{.}\PY{n}{add\PYZus{}directory}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{./syzygy}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{compare\PYZus{}with\PYZus{}syzygy}\PY{p}{(}\PY{n}{SYZYGY}\PY{p}{,} \PY{n}{S\PYZus{}N\PYZus{}Sequence\PYZus{}fen}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}


    % Add a bibliography block to the postdoc
    
\pagebreak
\pagenumbering{roman}
\setcounter{page}{6}
\section*{Literaturverzeichnis}
Carlstedt, J.: Die kleine Schachschule, Humboldt Verlag, o.O. 2014

chess.com o.V.: "Chess Engine", o. D., https://www.chess.com/terms/chess-engine, Einsichtnahme: 13.04.2022

Chess Programming Wiki o.V.: "Flipping Mirroring and Rotating
", o. D.,  https://www.chessprogramming.org/Flipping\_Mirroring\_and\_Rotating, Einsichtnahme: 13.04.2022

Fiekas, Niklas: "Syzygy endgame tablebases", o.D., https://syzygy-tables.info/, Einsichtnahme: 13.04.2022
\end{document}
